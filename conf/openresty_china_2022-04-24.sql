# ************************************************************
# Sequel Pro SQL dump
# Version 4541
#
# http://www.sequelpro.com/
# https://github.com/sequelpro/sequelpro
#
# Host: 127.0.0.1 (MySQL 5.5.31-log)
# Database: openresty_china
# Generation Time: 2022-04-24 03:02:28 +0000
# ************************************************************


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;


# Dump of table category
# ------------------------------------------------------------

DROP TABLE IF EXISTS `category`;

CREATE TABLE `category` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(15) NOT NULL DEFAULT '',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

LOCK TABLES `category` WRITE;
/*!40000 ALTER TABLE `category` DISABLE KEYS */;

INSERT INTO `category` (`id`, `name`, `create_time`)
VALUES
	(1,'分享','2016-02-17 16:22:04'),
	(2,'问答','2016-02-17 16:22:04'),
	(3,'技术','2022-04-22 20:17:28'),
	(4,'创意','2022-04-22 20:18:59'),
	(5,'好玩','2022-04-22 20:19:19'),
	(6,'城市','2022-04-22 20:19:31');

/*!40000 ALTER TABLE `category` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table collect
# ------------------------------------------------------------

DROP TABLE IF EXISTS `collect`;

CREATE TABLE `collect` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL DEFAULT '0',
  `topic_id` int(11) NOT NULL DEFAULT '0',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `unique_user_topic` (`user_id`,`topic_id`),
  KEY `index_user_id` (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='我的收藏';

LOCK TABLES `collect` WRITE;
/*!40000 ALTER TABLE `collect` DISABLE KEYS */;

INSERT INTO `collect` (`id`, `user_id`, `topic_id`, `create_time`)
VALUES
	(3,7,39,'2021-09-19 23:06:41'),
	(10,7,32,'2021-09-19 23:07:27'),
	(11,2,31,'2021-09-20 19:30:45'),
	(12,8,54,'2021-09-20 20:23:33'),
	(14,2,57,'2021-09-20 20:23:58'),
	(15,2,56,'2021-09-20 20:24:01'),
	(16,2,55,'2021-09-20 20:24:07'),
	(19,2,52,'2021-09-20 20:24:29'),
	(20,2,51,'2021-09-20 20:24:34'),
	(21,2,50,'2021-09-20 20:24:39'),
	(22,2,49,'2021-09-20 20:24:42'),
	(23,2,48,'2021-09-20 20:24:48'),
	(24,2,41,'2021-09-20 20:24:58'),
	(25,2,43,'2021-09-20 20:25:04'),
	(26,2,47,'2021-09-20 20:25:14'),
	(27,2,42,'2021-09-20 20:25:24'),
	(28,2,40,'2021-09-20 20:25:35'),
	(29,2,46,'2021-09-20 20:25:41'),
	(30,2,44,'2021-09-20 20:26:03'),
	(31,2,45,'2021-09-20 20:26:41'),
	(32,2,32,'2021-09-20 20:27:18'),
	(33,2,35,'2021-09-20 20:27:23'),
	(34,2,37,'2021-09-20 20:27:26'),
	(35,2,38,'2021-09-20 20:27:28'),
	(36,8,33,'2021-09-20 20:31:03'),
	(40,8,52,'2021-09-20 21:15:39'),
	(46,8,57,'2021-09-20 21:42:52'),
	(47,8,56,'2021-09-20 21:42:58'),
	(48,8,51,'2021-09-20 21:43:10'),
	(54,8,42,'2021-09-20 21:46:41'),
	(57,2,69,'2021-12-31 22:36:02'),
	(58,2,70,'2022-04-22 11:09:57');

/*!40000 ALTER TABLE `collect` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table comment
# ------------------------------------------------------------

DROP TABLE IF EXISTS `comment`;

CREATE TABLE `comment` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `topic_id` int(11) NOT NULL DEFAULT '0',
  `user_id` int(11) NOT NULL DEFAULT '0',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `content` varchar(3000) NOT NULL DEFAULT '',
  PRIMARY KEY (`id`),
  KEY `index_topic_id` (`topic_id`),
  KEY `index_user_id` (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

LOCK TABLES `comment` WRITE;
/*!40000 ALTER TABLE `comment` DISABLE KEYS */;

INSERT INTO `comment` (`id`, `topic_id`, `user_id`, `create_time`, `content`)
VALUES
	(5,33,2,'2021-09-20 15:53:10','### 这里填写我要发的内容XXX\n\n这里写我要发的正文内容，如果需要罗列展示了在内容里面一些小的格式，比如：\n\n- **加粗** - `-**加粗**`\n- *倾斜* - `*倾斜*`\n- ~~删除线~~ - `~~删除线~~`\n- `Code 标记` - ``Code 标记``\n- [超级链接](http://github.com) - `[超级链接](http://github.com)`\n- [poembro@126.com](mailto:poembro@126.com) - `[sumory.poembro@126.com](mailto:poembro@126.com)`\n'),
	(7,56,8,'2021-09-20 20:22:21','暗示企业公司要被一个叫蜂巢的给干掉？'),
	(8,33,8,'2021-09-20 20:34:56','漂亮 学习了'),
	(9,56,2,'2021-09-20 21:06:39','哈哈哈'),
	(14,91,2,'2022-04-22 18:46:55','投诉无门啊, 今天试了几个平台的投诉情况:\n1. https://www.12321.cn/ 网站 与 公众号一样 编写完相关信息，点击提交按钮,页面就卡住了。\n2. https://tousu.sina.com.cn/ 新浪旗下 黑猫投诉 编写完相关信息(与本文一致)，点击提交，页面提示有非法内容。\n'),
	(15,91,2,'2022-04-22 18:47:41','去联通的投诉平台 https://ts.10010.com/dc/pc/userpage/controlPage\n');

/*!40000 ALTER TABLE `comment` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table follow
# ------------------------------------------------------------

DROP TABLE IF EXISTS `follow`;

CREATE TABLE `follow` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `from_id` int(11) NOT NULL,
  `to_id` int(11) NOT NULL,
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `unique_relation` (`from_id`,`to_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

LOCK TABLES `follow` WRITE;
/*!40000 ALTER TABLE `follow` DISABLE KEYS */;

INSERT INTO `follow` (`id`, `from_id`, `to_id`, `create_time`)
VALUES
	(1,8,2,'2021-09-20 19:53:47'),
	(2,2,8,'2021-09-20 20:32:53');

/*!40000 ALTER TABLE `follow` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table like
# ------------------------------------------------------------

DROP TABLE IF EXISTS `like`;

CREATE TABLE `like` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL DEFAULT '0',
  `topic_id` int(11) NOT NULL DEFAULT '0',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `unique_user_topic` (`user_id`,`topic_id`),
  KEY `index_user_id` (`user_id`),
  KEY `index_topic_id` (`topic_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

LOCK TABLES `like` WRITE;
/*!40000 ALTER TABLE `like` DISABLE KEYS */;

INSERT INTO `like` (`id`, `user_id`, `topic_id`, `create_time`)
VALUES
	(1,2,39,'2021-09-19 22:50:37'),
	(2,7,39,'2021-09-19 22:57:40'),
	(3,7,32,'2021-09-19 23:06:59'),
	(4,8,37,'2021-09-20 10:48:35'),
	(5,2,33,'2021-09-20 15:54:02'),
	(6,2,31,'2021-09-20 19:30:42'),
	(7,8,32,'2021-09-20 20:03:23'),
	(8,8,54,'2021-09-20 20:23:33'),
	(9,2,58,'2021-09-20 20:23:52'),
	(10,2,57,'2021-09-20 20:23:57'),
	(11,2,56,'2021-09-20 20:24:01'),
	(12,2,55,'2021-09-20 20:24:06'),
	(13,2,54,'2021-09-20 20:24:14'),
	(14,2,53,'2021-09-20 20:24:22'),
	(15,2,52,'2021-09-20 20:24:28'),
	(16,2,51,'2021-09-20 20:24:33'),
	(17,2,50,'2021-09-20 20:24:38'),
	(18,2,49,'2021-09-20 20:24:42'),
	(19,2,48,'2021-09-20 20:24:47'),
	(20,2,41,'2021-09-20 20:24:58'),
	(21,2,43,'2021-09-20 20:25:04'),
	(22,2,47,'2021-09-20 20:25:13'),
	(23,2,42,'2021-09-20 20:25:23'),
	(24,2,40,'2021-09-20 20:25:34'),
	(25,2,46,'2021-09-20 20:25:41'),
	(26,2,44,'2021-09-20 20:26:03'),
	(27,2,45,'2021-09-20 20:26:40'),
	(28,2,32,'2021-09-20 20:27:18'),
	(29,2,35,'2021-09-20 20:27:22'),
	(30,2,37,'2021-09-20 20:27:25'),
	(31,2,38,'2021-09-20 20:27:27'),
	(32,8,33,'2021-09-20 20:31:02'),
	(33,8,56,'2021-09-20 21:04:20'),
	(34,8,58,'2021-09-20 21:09:58'),
	(35,8,52,'2021-09-20 21:15:30'),
	(36,8,57,'2021-09-20 21:35:24'),
	(38,8,51,'2021-09-20 21:43:06'),
	(39,8,42,'2021-09-20 21:46:19'),
	(40,2,69,'2021-12-31 22:35:47'),
	(42,2,70,'2022-04-22 11:09:52');

/*!40000 ALTER TABLE `like` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table notification
# ------------------------------------------------------------

DROP TABLE IF EXISTS `notification`;

CREATE TABLE `notification` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL DEFAULT '0' COMMENT '接收用户id',
  `type` int(11) NOT NULL DEFAULT '0' COMMENT '类型：0评论了你的文章 1评论中提到了你, 2某人关注了你',
  `from_id` int(11) NOT NULL DEFAULT '0' COMMENT '来自用户的id',
  `content` varchar(2000) NOT NULL COMMENT '内容',
  `topic_id` int(11) NOT NULL DEFAULT '0',
  `comment_id` int(11) NOT NULL DEFAULT '0',
  `status` int(11) NOT NULL DEFAULT '0' COMMENT '1已读，0未读',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  PRIMARY KEY (`id`),
  KEY `index_user_id` (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

LOCK TABLES `notification` WRITE;
/*!40000 ALTER TABLE `notification` DISABLE KEYS */;

INSERT INTO `notification` (`id`, `user_id`, `type`, `from_id`, `content`, `topic_id`, `comment_id`, `status`, `create_time`)
VALUES
	(1,2,0,7,'',39,1,1,'2021-09-19 22:58:50'),
	(2,2,0,7,'',39,2,1,'2021-09-19 23:05:40'),
	(3,1,0,8,'',31,3,0,'2021-09-20 10:46:11'),
	(4,1,0,8,'',31,4,0,'2021-09-20 11:57:42'),
	(5,7,0,2,'',33,5,0,'2021-09-20 15:53:10'),
	(6,8,1,2,'',31,6,1,'2021-09-20 19:50:16'),
	(7,1,0,2,'',31,6,0,'2021-09-20 19:50:16'),
	(8,2,2,8,'',0,0,1,'2021-09-20 19:53:47'),
	(9,8,0,8,'',56,7,1,'2021-09-20 20:22:21'),
	(10,8,2,2,'',0,0,1,'2021-09-20 20:32:53'),
	(11,7,0,8,'',33,8,0,'2021-09-20 20:34:56'),
	(12,8,0,2,'',56,9,1,'2021-09-20 21:06:39'),
	(13,8,0,2,'',40,10,1,'2021-09-20 21:08:11'),
	(14,8,0,2,'',40,11,1,'2021-09-20 21:08:31'),
	(15,2,1,8,'',40,12,1,'2021-10-22 10:19:06'),
	(16,8,0,8,'',40,12,0,'2021-10-22 10:19:06'),
	(17,2,1,8,'',40,13,1,'2021-10-22 10:19:44'),
	(18,8,0,8,'',40,13,0,'2021-10-22 10:19:44'),
	(19,2,0,2,'',91,14,1,'2022-04-22 18:46:55'),
	(20,2,0,2,'',91,15,1,'2022-04-22 18:47:41');

/*!40000 ALTER TABLE `notification` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table topic
# ------------------------------------------------------------

DROP TABLE IF EXISTS `topic`;

CREATE TABLE `topic` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(255) NOT NULL DEFAULT '',
  `content` text NOT NULL,
  `user_id` int(11) NOT NULL DEFAULT '0' COMMENT '创建者id',
  `user_name` varchar(255) NOT NULL DEFAULT '' COMMENT '创建者用户名',
  `like_num` int(11) NOT NULL DEFAULT '0' COMMENT '赞个数',
  `collect_num` int(11) NOT NULL DEFAULT '0' COMMENT '收藏数',
  `reply_num` int(11) NOT NULL DEFAULT '0' COMMENT '评论数',
  `follow` int(11) NOT NULL DEFAULT '0' COMMENT '关注数',
  `view_num` int(11) NOT NULL DEFAULT '0' COMMENT '阅读数',
  `last_reply_id` int(11) NOT NULL DEFAULT '0' COMMENT '最后回复者id',
  `last_reply_name` varchar(255) NOT NULL DEFAULT '' COMMENT '最后回复者用户名',
  `category_id` int(11) NOT NULL DEFAULT '0' COMMENT '所属类',
  `is_good` int(11) NOT NULL DEFAULT '0' COMMENT '1精华帖，0普通帖',
  `weight` int(11) NOT NULL DEFAULT '0' COMMENT '权重',
  `last_reply_time` timestamp NOT NULL DEFAULT '2000-01-01 00:00:00',
  `update_time` timestamp NULL DEFAULT NULL,
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

LOCK TABLES `topic` WRITE;
/*!40000 ALTER TABLE `topic` DISABLE KEYS */;

INSERT INTO `topic` (`id`, `title`, `content`, `user_id`, `user_name`, `like_num`, `collect_num`, `reply_num`, `follow`, `view_num`, `last_reply_id`, `last_reply_name`, `category_id`, `is_good`, `weight`, `last_reply_time`, `update_time`, `create_time`)
VALUES
	(33,'发帖最佳实践','### 这里填写我要发的内容XXX\n\n这里写我要发的正文内容，如果需要罗列展示了在内容里面一些小的格式，比如：\n\n- **加粗** - `-**加粗**`\n- *倾斜* - `*倾斜*`\n- ~~删除线~~ - `~~删除线~~`\n- `Code 标记` - ``Code 标记``\n- [超级链接](http://github.com) - `[超级链接](http://github.com)`\n- [poembro@126.com](mailto:poembro@126.com) - `[sumory.poembro@126.com](mailto:poembro@126.com)`\n\n\n\n \n\n# 分割线\n# 分割线\n# 分割线\n# 分割线\n# 上面这段内容的格式为:\n```\n### 这里填写我要发的内容XXX\n\n这里写我要发的正文内容，如果需要罗列展示了在内容里面一些小的格式，比如：\n\n- **加粗** - `-**加粗**`\n- *倾斜* - `*倾斜*`\n- ~~删除线~~ - `~~删除线~~`\n- `Code 标记` - ``Code 标记``\n- [超级链接](http://github.com) - `[超级链接](http://github.com)`\n- [poembro@126.com](mailto:poembro@126.com) - `[sumory.poembro@126.com](mailto:poembro@126.com)`\n\n\n```\n\n### 将灰色区域的内容复制，粘贴到编辑区域，然后点击预览。 即可看到对应格式效果。根据需要修改模板里的内容后，最终发布即可。',7,'momo',2,1,2,0,40,8,'test',1,1,2,'2021-09-20 20:34:56','2021-09-20 15:52:39','2016-02-27 22:44:23'),
	(35,'孩子3岁以前不建议用电动牙刷','口腔健康与全身健康息息相关。专家建议，婴儿出生之后，即使一颗牙齿也没有，家长也应每天用软纱布为孩子擦洗口腔。\n半岁左右牙齿萌出后，可以继续用这种方法擦洗口腔和牙齿表面。\n\n当多颗牙齿萌出后，家长可用指套刷或软毛刷为孩子每天刷牙2次，并清洁所有的牙面，特别是接近牙龈缘的部位，建议使用牙线帮助儿童清洁牙齿缝隙。\n儿童2岁左右开始学习刷牙，适合儿童的刷牙方法是“圆弧刷牙法”。\n\n具体操作方法是将刷毛放置在牙面上，轻压使刷毛弯曲，在牙面上画圈，每部位反复画圈 5 次以上，前牙内侧需将牙刷竖放，牙齿的各个面均应刷到。\n选择大小适宜的儿童牙刷，每两至三个月更换一次，当出现牙刷毛外翻或倒毛时，应及时更换牙刷，做到一人一刷一口杯。\n\n每天早晚刷牙，每次刷牙时间不少于 2 分钟，晚上睡前刷牙更重要。学龄前儿童很难完成精细复杂的刷牙动作，需要家长帮助和监督。\n此外，家长要注意给孩子选择适用其年龄阶段的牙刷，#孩子3岁以前不建议用电动牙刷#。',2,'admin',1,1,0,0,23,0,'',2,0,0,'2016-02-27 22:44:23','2021-09-20 15:14:52','2016-02-27 22:44:23'),
	(37,'孩子刚出生就需要做口腔清洁','  从小养成好的刷牙习惯，对人一生的健康都会起到积极作用。专家建议，孩子刚出生就需要做一些口腔清洁，通过按摩牙龈等方法让孩子适应口腔清洁的活动。在孩子长出第一颗牙之后，家长就应帮孩子刷牙。此外，家长要注意给孩子选择适用其年龄阶段的牙刷.',6,'jerry',2,1,0,0,34,0,'',1,0,0,'2016-02-27 22:44:23','2022-04-22 20:16:17','2016-02-27 22:44:23'),
	(38,'根管治疗后的现状','2019.12在武大口腔做的根管加陶瓷牙套。 完全不行，一旦咬到硬物就会破损。\n第一次是咬到米饭里的小石头,去补了，没花钱，临走时交代注意保护,下次就只能换牙套。\n平时都蛮注意基本不用那边牙吃饭。 结果晚上吃鸭脖，又中枪了。 非常绝望！\n\n问下大家，牙科这块医疗发展为何如此不堪。\n\n',7,'momo',1,1,0,0,79,0,'',2,0,0,'2016-02-27 22:44:23','2021-09-20 15:04:45','2016-02-27 22:44:23'),
	(39,'Markdown语法说明(发帖格式、排版范本) ','# Guide\n\n这是一篇讲解如何正确使用OpenResty China 的 **Markdown** 的排版示例，学会这个很有必要，能让你的文章有更佳清晰的排版。\n\n> 引用文本：Markdown is a text formatting syntax inspired\n\n## 语法指导\n\n### 普通内容\n\n这段内容展示了在内容里面一些小的格式，比如：\n\n- **加粗** - `**加粗**`\n- *倾斜* - `*倾斜*`\n- ~~删除线~~ - `~~删除线~~`\n- `Code 标记` - ``Code 标记``\n- [超级链接](http://github.com) - `[超级链接](http://github.com)`\n- [sumory.wu@gmail.com](mailto:sumory.wu@gmail.com) - `[sumory.wu@gmail.com](mailto:sumory.wu@gmail.com)`\n\n### 评论文章时提及用户\n\n@sumory  ... 通过 @ 可以在评论里面提及用户，信息提交以后，被提及的用户将会收到系统通知。以便让他来关注这个帖子或回帖。\n\n### 表情符号 Emoji\n\nOpenResty China 支持表情符号，你可以用系统默认的 Emoji 符号。\n也可以用图片的表情，输入 `:` 将会出现智能提示。\n\n#### 一些表情例子\n\n:smile: :laughing: :dizzy_face: :sob: :cold_sweat: :sweat_smile:  :cry: :triumph: :heart_eyes:  :satisfied: :relaxed: :sunglasses: :weary:\n\n:+1: :-1: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :shit: :sweat_drops: :exclamation: :anger:\n\n对应字符串表示如下：\n\n```\n:smile: :laughing: :dizzy_face: :sob: :cold_sweat: :sweat_smile:  :cry: :triumph: :heart_eyes:  :satisfied: :relaxed: :sunglasses: :weary:\n:+1: :-1: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :shit: :sweat_drops: :exclamation: :anger:\n```\n\n更多表情请访问：[http://www.emoji-cheat-sheet.com](http://www.emoji-cheat-sheet.com)\n\n### 大标题 - Heading 3\n\n你可以选择使用 H2 至 H6，使用 ##(N) 打头，H1 不能使用，会自动转换成 H2。\n\n> NOTE: 别忘了 # 后面需要有空格！\n\n#### Heading 4\n\n##### Heading 5\n\n###### Heading 6\n\n### 代码块\n\n#### 普通\n\n```\n*emphasize*    **strong**\n_emphasize_    __strong__\n@a = 1\n```\n\n#### 语法高亮支持\n\n如果在 ``` 后面更随语言名称，可以有语法高亮的效果哦，比如:\n\n##### 演示 Lua 代码高亮\n\n```lua\nlocal lor = require(\"lor.index\")\nlocal app = lor()\n\napp:get(\"/\", function(req, res, next)\n    res:send(\"hello world!\")\nend)\n\napp:run()\n```\n\n##### 演示 Javascript 高亮\n\n```js\n(function (L) {\n    var _this = null;\n    L.Common = L.Common || {};\n    _this = L.Common = {\n        data: {},\n \n        init: function () {\n            console.log(\"init function\");\n        },\n\n        formatDate: function (now) {\n            var year = now.getFullYear();\n            var month = now.getMonth() + 1;\n            var date = now.getDate();\n            var hour = now.getHours();\n            var minute = now.getMinutes();\n            var second = now.getSeconds();\n            if (second < 10) second = \"0\" + second;\n            return year + \"-\" + month + \"-\" + date + \" \" + hour + \":\" + minute + \":\" + second;\n        }\n    };\n}(APP));\n```\n\n##### 演示 YAML 文件\n\n```yml\nzh-CN:\n  name: 姓名\n  age: 年龄\n```\n\n> Tip: 语言名称支持下面这些: `ruby`, `python`, `js`, `html`, `erb`, `css`, `coffee`, `bash`, `json`, `yml`, `xml` ...\n\n### 有序、无序列表\n\n#### 无序列表\n\n- Ruby\n  - Rails\n    - ActiveRecord\n- Go\n  - Gofmt\n  - Revel\n- Node.js\n  - Koa\n  - Express\n\n#### 有序列表\n\n1. Node.js\n  1. Express\n  2. Koa\n  3. Sails\n2. Ruby\n  1. Rails\n  2. Sinatra\n3. Go\n\n### 表格\n\n如果需要展示数据什么的，可以选择使用表格哦\n\n| header 1 | header 3 |\n| -------- | -------- |\n| cell 1   | cell 2   |\n| cell 3   | cell 4   |\n| cell 5   | cell 6   |\n\n### 段落\n\n留空白的换行，将会被自动转换成一个段落，会有一定的段落间距，便于阅读。\n\n请注意后面 Markdown 源代码的换行留空情况。',2,'admin',2,1,0,0,230,7,'momo',1,1,1,'2021-09-19 23:05:40','2022-04-22 19:50:55','2016-02-27 22:44:23'),
	(44,'范丞丞首部电影门锁亮相北影节','身着纯黑挂锁装饰西服套装，即将亮相北京国际电影节开幕式红毯。光影流转，“门锁”在身，表达着他首部电影作品对于自己的意义。《门锁》小吴，期待早日相见。[耶]\n秋雨微凉，共同等待北京国际电影节大幕拉开，合力生光。\n\n ![wm02.jpg](/static/files/1632140003.073.jpg) ',8,'test',1,1,0,0,8,0,'',1,0,0,'2000-01-01 00:00:00',NULL,'2021-09-20 20:13:24'),
	(45,'北影节开幕红毯','北京电影节“天坛奖”评委会亮相开幕红毯群访，主席巩俐和评委会成员陈坤、陈正道、乌尔善、张颂文与媒体打招呼后离开。',8,'test',1,1,0,0,4,0,'',1,0,0,'2000-01-01 00:00:00',NULL,'2021-09-20 20:14:00'),
	(50,'嫦娥回不了广寒宫的原因','嫦娥：今年我不会回不了广寒宫过中秋了吧\n\n ![02.jpg](/static/files/1632140196.947.jpg) ',8,'test',1,1,0,0,10,0,'',1,0,0,'2000-01-01 00:00:00','2022-04-22 20:14:25','2021-09-20 20:16:38'),
	(59,'laravel安装篇之Composer','# Composer   PHP依赖管理的新时代\n\n### 原理就是借用PHP 的phar扩展特性 把代码打包   然后用php的cli 模式执行这个包       跟java一样打成一个tar包, \n```\ncurl -sS https://getcomposer.org/installer | php\n\n如果有错\n[root@www php]# cd 进入PHP源码包目录/ext/phar \n[root@www php]# phpize\n[root@www php]# ./configure --with-php-config=/usr/local/php/bin/php-config \n[root@www php]#make && make install \n\n\n\n设置 composer 镜像源\n[root@www php]#composer config -g repo.packagist composer https://packagist.phpcomposer.com\n\n\n\n\n#安装包的时候注意 要保证当前目录下有  composer.json 文件\n[root@www php]#vi composer.json\n{\n	\"require\": {\n		\"monolog/monolog\": \"1.2.*\"   #########表示待会执行时会在当前目录下创建一个vendor目录\n	}\n}\n  \n[root@www php]# php composer.phar install     \n	Do not run Composer as root/super user! See https://getcomposer.org/root for details\n	Loading composer repositories with package information\n	Updating dependencies (including require-dev)\n	  - Installing guzzlehttp/promises (1.3.0)\n		Downloading: 100%         \n\n	  - Installing psr/http-message (1.0.1)\n		Downloading: Failed       \n		Downloading: 100%         \n\n	  - Installing guzzlehttp/psr7 (1.3.1)\n		Downloading: 100%         \n\n	  - Installing guzzlehttp/guzzle (dev-master 471026d)\n		Cloning 471026d23a14f6eadd0147eb5697f48ebe6adec8\n		Failed to download guzzlehttp/guzzle from source: Failed to clone https://github.com/guzzle/guzzle.git, git was not found, check that it is installed and in your PATH env.\n\n	sh: git: command not found\n\n		Now trying to download from dist\n	  - Installing guzzlehttp/guzzle (dev-master 471026d)\n		Downloading: 100%         \n\n	Writing lock file\n	Generating autoload files\n	You have new mail in /var/spool/mail/root\n\n	\n	\n	\n	\n	\n	\n \n# 遇到问题 (在docker里面执行安装composer出现错误)\n[root@www php]#/data/web/test # curl -sS https://getcomposer.org/installer -k | php\nAll settings correct for using Composer\nDownloading...\nThe \"https://getcomposer.org/versions\" file could not be downloaded: SSL operation failed with code 1. OpenSSL Error messages:\nerror:1416F086:SSL routines:tls_process_server_certificate:certificate verify failed\nFailed to enable crypto\nfailed to open stream: operation failed\nRetrying...\nThe \"https://getcomposer.org/versions\" file could not be downloaded: SSL operation failed with code 1. OpenSSL Error messages:\nerror:1416F086:SSL routines:tls_process_server_certificate:certificate verify failed\nFailed to enable crypto\nfailed to open stream: operation failed\nRetrying...\nThe \"https://getcomposer.org/versions\" file could not be downloaded: SSL operation failed with code 1. OpenSSL Error messages:\nerror:1416F086:SSL routines:tls_process_server_certificate:certificate verify failed\nFailed to enable crypto\nfailed to open stream: operation failed\nThe download failed repeatedly, aborting.\n\n\n# 解决就是时间更新问题   以及 网络代理\nyum -y install ntp ntpdate\nntpdate cn.pool.ntp.org  /*同步网络时间到本机系统时间*/\nhwclock --systohc       /*同步系统时间到硬件时间*/\ntimedatectl\ndate  \"+%F %T\"  /*查看时间*/\n\n	\n\n# 创建 1个 名为 blog 项目\n	\n[root@www /data/web/test]#  php composer.phar -vvv create-project --prefer-dist laravel/laravel blog \"5.8.*\"\nCreating a \"laravel/laravel\" project at \"./blog\"\nInstalling laravel/laravel (v5.8.35)\n  - Downloading laravel/laravel (v5.8.35)\n  - Installing laravel/laravel (v5.8.35): Extracting archive\nCreated project in /data/web/test/blog\n\n\n\n```\n\n\n\n',2,'admin',0,0,0,0,35,0,'',3,0,0,'2000-01-01 00:00:00','2022-04-22 17:57:59','2021-09-24 14:28:46'),
	(60,'拉取php7.4版本的docker','```\nhttps://hub.docker.com/_/php?tab=tags&page=1&ordering=last_updated\n\ndocker pull php:7.4.24-fpm-alpine3.14\n\n\n\n docker run -p 127.0.0.1:9000:9000 -d --network=host --name my-running-php -v \"$PWD\":/data/web/test -w /data/web/test 0f53f2917118\n\ndocker container exec -it 4f2ca7399f1d /bin/sh\n\n\n如果在docker php容器内部 增加了 什么东西 要备份 \n \n\n3.备份当前已经改好的\ndocker commit -a \"poemrbo\" -m \"提交时的说明文字\" -p efb9d80324c3 my-running-php:php7.4prod \n    -a :提交的镜像作者； \n    -c :使用Dockerfile指令来创建镜像； \n    -m :提交时的说明文字； \n    -p :在commit时，将容器暂停。\n\n\n\n```',2,'admin',0,0,0,0,27,0,'',3,0,0,'2000-01-01 00:00:00','2022-04-22 17:57:51','2021-09-24 14:33:52'),
	(61,'laravel学习笔记一','```\n# 配置文件 .env 是区分各开发环境 生产环境的 比如数据库配置\n/data/web/test # cd blog/\n/data/web/test/blog # cat .env\nAPP_NAME=Laravel \nAPP_DEBUG=true \n\nDB_CONNECTION=mysql\nDB_HOST=127.0.0.1\nDB_PORT=3306\nDB_DATABASE=laravel\nDB_USERNAME=root\nDB_PASSWORD=\n\n# 而 Laravel 框架的所有配置文件都保存在 config 目录中，如config/social.php。\nreturn [\n   ‘debug\' => env(\'APP_DEBUG\', false),  //把.env里面的东西用env()函数搬运过来\n    \'weixin\' => [\n        \'url\' => \'https://weixin.com/qrcode.png\',\n        \'username\' => \'my_wexin_name\'\n    ],\n    \'weibo\' => [\n        \'url\' => \'https://weibo.com/my_acount\',\n        \'username\' => \'my_acount\'\n    ]\n];\n\n当让可以 动态设置\nconfig(\'social.weibo.username\', \'默认值\')\n// 上面等同于下面，注意是 `get` 而不是 `set`\nConfig::get(\'social.weibo.username\', \'默认值\');\n\n \n测试如下:\n$ php artisan tinker\n>>> env(\'APP_DEBUG\')\n=> true\n>>> getenv(\'APP_DEBUG\')\n=> \"true\"\n>>> $_ENV[\'APP_DEBUG\']\n=> \"true\"\n>>> $_SERVER[\'APP_DEBUG\']\n=> \"true\"\n>>> config(\'app.debug\')\n=> true\n\n\n# 路由\n### 普通http请求方法限制\nRoute::match([\'get\', \'post\'], \'/\', function () {\n    //支持两种方法\n});\n\nRoute::any(\'foo\', function () {\n    //可以接收所有的方法\n})；\n\n\n\n### 路径上的参数限制\nRoute::get(\'user/{id}/{name}\', function ($id, $name) {\n    // 同时限定两个参数\n})->where([\'id\' => \'[0-9]+\', \'name\' => \'[a-z]+\']);\n \n//全局参数限制(针对所有 路径上的id)\napp/Providers/RouteServiceProvider.php\n//定义路由模型绑定、路由全局约束等\npublic function boot()\n{\n    Route::pattern(\'id\', \'[0-9]+\'); \n    parent::boot();\n}\n\n\n\n\n### 给路由命名 (可以为指定路由生成URL或重定向)\nRoute::get(\'user/profile\', \'UserProfileController@show\')->name(\'profile\');\n// 生成 URL...\n$url = route(\'profile\');\n//生成 URL 带参数\nRoute::get(\'user/{id}/profile\', function ($id) {\n    //todo\n})->name(\'profile\');\n$url = route(\'profile\', [\'id\' => 1]);\n \n// 生成重定向...\nreturn redirect()->route(\'profile\');\n\n\n\n\n### 访问控制 (让某个用户访问身份验证，并且访问频率每分钟不超过60)\nRoute::middleware(\'auth:api\', \'throttle:60,1\')->group(function () {\n    Route::get(\'/user\', function () {\n        //\n    });\n});\n\n\n\n# 中间件 (Laravel 自带了 身份验证、CSRF 保护 CORS 等中间件。都位于 app/Http/Middleware 目录。)\n\n### 定义中间件 (会在app/Http/Middleware目录下创建CheckAge类文件)\nphp artisan make:middleware CheckAge \n\n<?php\n\nnamespace App\\Http\\Middleware;\n\nuse Closure;\n\nclass CheckAge\n{\n    /**\n     * Handle an incoming request.\n     *\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  \\Closure  $next\n     * @return mixed\n     */\n    public function handle($request, Closure $next)\n    {\n        if ($request->age <= 200) {\n            return redirect(\'home\');  // age 参数小于或等于 200 则重定向\n        }\n\n        return $next($request); // age 大于200 继续后续handler\n    }\n}\n\n### 注册中间件\n- 全局中间件  只需要在app/Http/Kernel.php 中的 $middleware 属性中列出这个中间件\n- 为路由分配中间件  需要在app/Http/Kernel.php 中分配1个键  将其放入该类中的 $routeMiddleware 属性中\n- 注意如果没有放在可直接填写完整命名空间加双冒号class即可\n\n### 中间组件\n- 如果需要某1个键把多个中间件打包成1个组，方便将其应用到路由中去，可以使用Http 核心的 $middlewareGroups 属性。\n    protected $middlewareGroups = [\n        \'web\' => [\n            \\App\\Http\\Middleware\\EncryptCookies::class,......\n        ],\n\n        \'api\' => [\n            \'throttle:60,1\',\n            \'bindings\',\n        ],\n    ];\n使用方法\nRoute::group([\'middleware\' => [\'api\']], function () {\n    //\n});\n\n### 中间件 排序\n可以使用 app/Http/Kernel.php 文件的 $middlewarePriority 属性指定中间件优先级：\n\n### 中间件参数\n需要在执行给定操作之前验证用户是否属于给定的「角色」 ，可以创建一个 CheckRole 中间件，由它来接收「角色」名称作为附加参数。\n附加的中间参数应该在 $next 参数之后传递给中间件：\n \n<?php \nnamespace App\\Http\\Middleware; \nuse Closure;\n\nclass CheckRole\n{ \n    public function handle($request, Closure $next, $role)\n    {\n        if (! $request->user()->hasRole($role)) {\n            // Redirect...\n        }\n\n        return $next($request);\n    } \n}\n\n\n定义路由时通过一个 : 来隔开中间件名称和参数来指定中间件参数。多个参数就使用逗号分隔：\nRoute::put(\'post/{id}\', function ($id) {\n    //\n})->middleware(\'role:editor\');\n\n\n\n\n## 接受用户输入     Illuminate\\Support\\Facades\\Input\n\nFacades : \"门面\" 的意思 。门面是介于一个类的实例化与没有实例化中间的一个状态。其实是静态方法\n\nInput::get(\"参数的名字\"，\"如果用户没传 使用该默认值\")\nInput::all() 获取所有的输入\nInput::only([]) 获取指定几个 输入\nInput::exceput([])  获取指定几个用户的输入 以外的所有参数\nInput::has(\'name\')  判断某个输入的参数是否存在\n上述方法 即可以 获取get中的信息 也可以获取post中的信息\n\n\n如果每次都嫌弃   Illuminate\\Support\\Facades\\Input 太长\n则可以在 config/app.php中定义长串的别名  (在 aliase 数组中定义别名)\n\n\n调试函数 dd($app)   ==等价于==>  var_dump + die()\n\n\n\n\n\n\n## laravel 的 facades 门面   (是1个可以在容器中访问对象的类)\nuse Illuminate\\Support\\Facades\\Cache;\nRoute::get(\'facades\', function ($id) {\n    Cache([\'name\'=>\"张三\"], 3000);   // 将会在storage/framework/cache/data/创建1个文件\n    Cache::get(\'name\')  //底层会走__call()\n\n    或者=>   resolve(\"cache.store\")->get(\"name\") \n\n    或者=> Cache(\"name\")\n})\n\n## laravel 的 Contracts 契约 都是用来调用底层代码实现 \nFacades 是引入到命名空间上的门面    \nContracts  是定义了一堆接口  \n每一个Facades 门面 都有个相对应的Contracts  契约 \n\nRoute::get(\'Contracts\', function (Illuminate\\Contracts\\Cache\\Factory $cache) {\n      $cache->put([\'name\' => \"张三\"], 3000)\n      $cache->get(\"name\")\n})\n\n\n\nUser::where(\'is_official\', true)->value(\'id\')   获取一条数据的 id 字段值\n\nUser::where(\'is_official\', true)->pluck(\'id\')   \n// 表示 select * from users where is_official=true  拿到所有数据后； pluck(\'id\') 是将到所有id的值提出来 组成一个数组 [1,2,3,4] \n\n\n\n\n\n\n\nmigration (laravel数据迁移)\n1.本质上就是mysql中，有一个migration表，记录了 所有的cmd脚本文件名。 \n每个脚本只干1件事情 \n如：创建表是一个文件。 \n增加1个字段也是一个文件。\n\n2. 每次执行migration命令时 它会扫描一下表中是否有对应目录的文件，如果mysql表中已经有了则不执行老的脚本。\n\n3.每次想执行sql 时候 先要生成文件模版，\n然后修改模版里面的 up down 方法。最后执行\n\n\n\n\n\n```',2,'admin',0,0,0,0,46,0,'',3,0,0,'2000-01-01 00:00:00','2022-04-22 17:57:44','2021-09-24 15:53:42'),
	(63,'artisan 在laravel命令行中起什么作用','## artisan 是laravel 的命令行接口名称， 提供了一些命令帮助laravel开发应用\n\n比如 php artisan migrate --help    (用来做数据迁移的)\n\n我们也可以自定义  php artisan lor \n\n具体实现 ： 自定义命令默认放在 app/Console/Commands 目录，当然了 要是在composer.json中配置了自动加载，可以随意放在任何目录+\n\nphp artisan make:console Lor (Artisan命令生成文件，然后去填充文件内容即可)\n\n完了之后，app/Console/Commands/Lor.php 类下面写了 send 方法\n\nphp artisan make:console Lor --command=lor:send\n```\n<?php\n\nnamespace App\\Console\\Commands;\n\nuse App\\User;\nuse App\\DripEmailer;\nuse Illuminate\\Console\\Command;\n\nclass Lor extends Command\n{\n    /**\n     * 命令行的名称及用法。\n     * (注意)该属性定义命令行调用时必须输入的格式 \n     \'email:send {user} {--queue}\'          回头命令行调用 : php artisan email:send 1 --queue=default \n     * @var string\n     */\n    protected $signature = \'lor:send {user}\';\n\n    /**\n     * 命令行的概述。\n     *\n     * @var string\n     */\n    protected $description = \'Send drip e-mails to a user\';\n\n    /**\n     * 滴灌电子邮件服务。\n     *\n     * @var DripEmailer\n     */\n    protected $drip;\n\n    /**\n     * 创建新的命令实例。\n     *\n     * @param  DripEmailer  $drip\n     * @return void\n     */\n    public function __construct(DripEmailer $drip)\n    {\n        parent::__construct();\n\n        $this->drip = $drip;\n    }\n\n    /**\n     * 运行命令。\n     * \n     * @return mixed\n     */\n    public function handle()\n    {\n         $name = $this->ask(\'你是名字是?\');\n         $password = $this->secret(\'密码是？\');\n         if ($this->confirm(\'你希望继续吗? [y|N]\')) {\n             //\n         }\n         $name = $this->anticipate(\'你的名字是?\', [\'Taylor\', \'Dayle\']);\n         $name = $this->choice(\'你的名字是?\', [\'Taylor\', \'Dayle\'], false);\n         $this->info(\'把我显示在界面上\');\n         $this->error(\'有东西出问题了！\');\n         $this->line(\'把我显示在界面上\');\n               $this->drip->send(User::find($this->argument(\'user\'))); //可以获取命令行参数\n         }\n}\n```',2,'admin',0,0,0,0,24,0,'',3,0,0,'2000-01-01 00:00:00','2022-04-22 17:57:37','2021-09-26 17:04:18'),
	(64,'composer.json中的字段含义','```\n{\n    \"name\": \"laravel/laravel\",   /* 包名称   供应商名称 + 项目名称  用 / 分隔 */\n    \"type\": \"project\",    /* 包的安装类型，1. 默认为 library。 2. project 表示当前是1个项目，而不是库 3. metapackage: 当一个空的包，包含依赖并且需要触发依赖的安装*/\n    \"description\": \"The Laravel Framework.\", /* 描述 */\n    \"keywords\": [  \n        \"framework\",\n        \"laravel\"\n    ],\n   \"authors\": [\n        {\n            \"name\": \"Nils Adermann\",\n            \"email\": \"naderman@naderman.de\",\n            \"homepage\": \"http://www.naderman.de\",\n            \"role\": \"Developer\"\n        },\n        {\n            \"name\": \"Jordi Boggiano\",\n            \"email\": \"j.boggiano@seld.be\",\n            \"homepage\": \"http://seld.be\",\n            \"role\": \"Developer\"\n        }\n    ],\n    \"license\": \"MIT\",\n    \"require\": {\n        \"php\": \"^7.1.3\",\n        \"doctrine/dbal\": \"^2.13\",\n        \"elasticsearch/elasticsearch\": \"7.9.1\",\n        \"fideloper/proxy\": \"^4.0\",\n        \"fruitcake/laravel-cors\": \"^2.0\",\n        \"guzzlehttp/guzzle\": \"6.3.3\",\n        \"laravel/framework\": \"5.8.*\",\n        \"laravel/tinker\": \"^1.0\",\n        \"nategood/httpful\": \"^0.3.2\",\n        \"predis/predis\": \"^1.1\",\n        \"qcloud/cos-sdk-v5\": \"^2.2\",\n        \"ramsey/uuid\": \"3.x-dev\",\n        \"symfony/process\": \"4.4.26\",\n        \"tucker-eric/eloquentfilter\": \"^2.4\",\n        \"tymon/jwt-auth\": \"^1.0\"\n    },\n    \"require-dev\": { /*这个列表是为开发或测试等目的，额外列出的依赖。 */\n        \"beyondcode/laravel-dump-server\": \"^1.0\",\n        \"filp/whoops\": \"^2.0\",\n        \"fzaninotto/faker\": \"^1.4\",\n        \"mockery/mockery\": \"^1.0\",\n        \"nunomaduro/collision\": \"^3.0\",\n        \"phpunit/phpunit\": \"^7.5\"\n    },\n    \"config\": { \n        \"optimize-autoloader\": true,\n        \"preferred-install\": \"dist\", /*默认auto 它可以是 source、dist 或 auto。这个选项允许你设置 Composer 的默认安装方法*/\n        \"sort-packages\": true\n    },\n    \"extra\": {\n        \"laravel\": {\n            \"dont-discover\": []\n        }\n    },\n    \"autoload\": {\n        \"psr-4\": {\n            \"App\\\\\": \"app/\", \n            \"Common\\\\\": \"packagist/stnts-common/\",\n            \"Cos\\\\\": \"packagist/cos/src/\",\n            \"Easydown\\\\\": \"packagist/easydown/src/\",\n            \"BaseCommon\\\\\": \"packagist/base-common/\",\n            \"Aiyutan\\\\\": \"packagist/aiyutan/src/\",\n            \"Ifanni\\\\\": \"packagist/ifanni/src/\",     /* 当 代码中遇到Ifanni\\\\ 时 则自动加载器将去 packagist/ifanni/src/ 目录下查找对应类文件*/\n            \"GoStart\\\\\": \"packagist/go-start/src/\",\n            \"OperationLog\\\\\": \"packagist/operation-log/src/\"\n        },\n        \"classmap\": [  /*  引用的所有组合都会在install/update过程中生成，并存储到 vendor/composer/autoload_classmap.php文件中去，这个map是经过扫描指定目录所有.php和.inc文件里内置类而得到的*/\n            \"database/seeds\",\n            \"database/factories\"\n        ],\n        \"files\": [  /*  如果 每次请求时都要载入某些文件,  比如通用函数库 而非类库 就可以放在这里*/\n            \"bootstrap/helper.php\" \n        ]\n    },\n    \"autoload-dev\": { /*以开发为目的的自定义加载规则*/\n        \"psr-4\": {\n            \"Tests\\\\\": \"tests/\"\n        }\n    },\n    \"minimum-stability\": \"dev\", /*默认为 stable 表示稳定包   dev表示开发中的包 */\n    \"prefer-stable\": true, /*为true时 Composer 将优先使用它，表示更稳定的包版本*/\n    \"scripts\": { /* 允许你在安装过程中的各个阶段挂接脚本*/\n        \"post-autoload-dump\": [ /*在自动加载器被转储后触发，无论是 install/update 还是 dump-autoload 命令都会触发。*/\n            \"Illuminate\\\\Foundation\\\\ComposerScripts::postAutoloadDump\",\n            \"@php artisan package:discover --ansi\"\n        ],\n        \"post-root-package-install\": [ /*在 create-project 命令期间，根包安装完成后触发。*/\n            \"@php -r \\\"file_exists(\'.env\') || copy(\'.env.example\', \'.env\');\\\"\"\n        ],\n        \"post-create-project-cmd\": [ /*在 create-project 命令执行后触发。*/\n            \"@php artisan key:generate --ansi\"\n        ]\n    }\n}\n\n\n```',2,'admin',0,0,0,0,24,0,'',3,0,0,'2000-01-01 00:00:00','2022-04-22 17:57:27','2021-09-26 19:30:44'),
	(65,'php之trait 用来包一些公共属性方法供其他类使用','## php 是单继承语言,无法同时从两个基类中继承属性和方法, 而Trait就是为了解决这个问题而生\n\n```\ntrait Com{\n    public $name = \"武汉xx网络科技\"；\n    public function handle(){\n        echo \"hello \" .. this->name;\n    }\n}\n\nclass A{\n    public function eat(){\n         echo \"eat\";\n    }\n}\n\nclass B extends A{\n    use Com;\n    public function drive(){\n           echo \"drive\";\n    }\n}\n\n$obj = new B();\n$obj->drive();\n$obj->eat();\n$obj->handle();\n\n\n\n\n\n//trait1 与 trait 2内部都有相同方法  \n<?php\ntrait trait1{\n    public function eat(){\n        echo \"This is trait1 eat\";\n    }\n    public function drive(){\n        echo \"This is trait1 drive\";\n    }\n}\ntrait trait2{\n    public function eat(){\n        echo \"This is trait2 eat\";\n    }\n    public function drive(){\n        echo \"This is trait2 drive\";\n    }\n}\nclass cat{\n    use trait1,trait2{\n        trait1::eat insteadof trait2;  //用 trait1 下面的 eat方法 替换  trait2下面的 eat方法 \n        trait1::drive insteadof trait2;\n    }\n}\nclass dog{\n    use trait1,trait2{\n        trait1::eat insteadof trait2;  \n        trait1::drive insteadof trait2;\n        trait2::eat as eaten;  //给trait2的eat方法  起个别名  依旧能访问\n        trait2::drive as driven;\n    }\n}\n$cat = new cat();\n$cat->eat();\necho \"<br/>\";\n$cat->drive();\necho \"<br/>\";\necho \"<br/>\";\necho \"<br/>\";\n$dog = new dog();\n$dog->eat();\necho \"<br/>\";\n$dog->drive();\necho \"<br/>\";\n$dog->eaten();\necho \"<br/>\";\n$dog->driven();\n?>\n```',2,'admin',0,0,0,0,22,0,'',3,0,0,'2000-01-01 00:00:00','2022-04-22 17:57:18','2021-09-27 11:28:34'),
	(66,'gorm 学习使用','##  gorm  简介\n一个用来访问数据的库，而且被封装过的，开发人员用着可以节省代码量的库\n\n 官方文档 https://gorm.io/zh_CN/docs/models.html\n\n## 约定\n```\ngorm 使用id作为主键，默认使用结构体名 “蛇形复数“做表名，同时语义符合英文语法(尽管形式很生猛)，可以通过Config进行选择是否使用复数。\n字段名的 蛇形 作为列名，并使用 CreatedAt、UpdatedAt 字段追踪创建、更新时间\n例如:\n// data将会变成表名称\ntype Data struct {\n	ID  uint   `json:\"id,omitempty\" gorm:\"primaryKey\"`\n	Msg string `json:\"msg,omitempty\" gorm:\"type:varchar(10) unique\"`\n}\n//users 将会变成表名称    接口体名使用AaBc 则aa_bcs是表名\ntype User struct {\n  ID   string // 默认情况下，名为 `ID` 的字段会作为表的主键  \n  UUID   string `gorm:\"primaryKey\"`  //这里强制指定其他字段作为主键\n  Name string\n}\n\n\ntype User struct {\n  gorm.Model   //该字段  等价于 4个默认字段\n  Name string\n}\n// 等效于\ntype User struct {\n  ID        uint           `gorm:\"primaryKey\"`\n  CreatedAt time.Time\n  UpdatedAt time.Time\n  DeletedAt gorm.DeletedAt `gorm:\"index\"` \n  Name string `gorm:\"<-:create\"` // 允许读和创建\n  Name string `gorm:\"<-:update\"` // 允许读和更新\n  Name string `gorm:\"<-\"`        // 允许读和写（创建和更新）\n  Name string `gorm:\"<-:false\"`  // 允许读，禁止写\n  Name string `gorm:\"->\"`        // 只读（除非有自定义配置，否则禁止写）\n  Name string `gorm:\"->;<-:create\"` // 允许读和写\n  Name string `gorm:\"->:false;<-:create\"` // 仅创建（禁止从 db 读）\n  Name string `gorm:\"-\"`  // 通过 struct 读写会忽略该字段  注意 使用 GORM Migrator 创建表时，不会创建该字段 因为它被忽略了.\n  Author  Author `gorm:\"embedded;embeddedPrefix:author_\"`  //使用结构体字段 可以通过 embedded 将其嵌入      等价于  AuthorName  string, AuthorEmail string\n\n  Field int `json:\"-\"` // 字段被本包忽略\n  Field int `json:\"myName\"`  // 字段在json里的键为\"myName\"\n  Field int `json:\"myName,omitempty\"`  // 字段在json里的键为\"myName\"且如果字段为空值将在生成json 后 json里面看不到该字段  \n  Field int `json:\",omitempty\"` // 字段在json里的键为\"Field\"（默认值），但如果字段为空值会跳过；注意前导的逗号\n  Int64String int64 `json:\",string\"` //强制指定 编码为字符串类型 ,但它只适用于字符串、浮点数、整数类型的字段\n}\n\n//更多标签  https://gorm.io/zh_CN/docs/models.html#embedded_struct\n```\n\n\n\n## 案例\n```\npackage main\n\nimport (\n   \"fmt\" \n   \"github.com/jinzhu/gorm\"\n   _ \"github.com/jinzhu/gorm/dialects/mysql\"\n)\n\ntype Animal struct {\n   ID   int64\n   Name string\n   Age  int64\n}\n\nfunc main() {\n   db, err := gorm.Open(\"mysql\", \"root:root@(localhost)/gormdemo?charset=utf8&parseTime=true&loc=Local\")\n   if err != nil {\n      fmt.Println(\"connect db error: \", err)\n   }\n   defer db.Close()\n   init_data(db)\n   query_test(db)\n   err=update_test(db)\n   if err!=nil{\n      fmt.Println(err)\n   }\n   err=delet_test(db)\n   if err!=nil{\n      fmt.Println(err)\n   }\n   err=trans_test(db)\n   if err!=nil{\n      fmt.Println(err)\n   }\n}\nfunc init_data(db *gorm.DB)  {\n   sql:=`DROP TABLE IF EXISTS animals ;`\n   db.Exec(sql)\n   sql=`\n      CREATE TABLE animals (\n        id BIGINT(20) NOT NULL AUTO_INCREMENT,\n        NAME VARCHAR(255) DEFAULT \'galeone\',\n        age INT(10) UNSIGNED DEFAULT \'0\',\n        PRIMARY KEY (id)\n      ) ENGINE=INNODB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8;`\n   db.Exec(sql)\n   sql=`\n      INSERT INTO animals SELECT \'1\', \'demo-test\', \'20\'\n      UNION ALL SELECT \'2\', \'galeone\', \'30\'\n      UNION ALL SELECT \'3\', \'demotest\', \'30\'\n      UNION ALL SELECT \'4\', \'jim\', \'90\'\n      UNION ALL SELECT\'5\', \'jimmy\', \'10\'\n      UNION ALL SELECT \'6\', \'jim\', \'23\'\n      UNION ALL SELECT \'7\', \'test3\', \'27\'\n      `\n   db.Exec(sql)\n}\nfunc create_test(db * gorm.DB)(error) {\n   animal := Animal{Name: \"demo-test\", Age: 20}\n   db.Create(&animal)\n   return nil\n}\nfunc query_test(db *gorm.DB)(error)  {\n   //根据主键查询第一条记录\n   var animal Animal\n   db.First(&animal)\n   fmt.Println(animal)\n\n   //根据主键查询最后一条记录\n   var animal2 Animal\n   db.Last(&animal2)\n   fmt.Println(animal2)\n\n   //指定某条记录（仅当主键为整型时可用）\n   var animal3 Animal\n   db.First(&animal3, 2)\n   fmt.Println(animal3)\n\n   //where条件\n   //符合条件的第一条记录\n   var animal4 Animal\n   db.Where(\"name = ?\", \"demo-test\").First(&animal4)\n   fmt.Println(\"where : \", animal4, animal4.ID, animal4.Name, animal4.Age)\n\n   //符合条件的所有记录\n   var animals5 []Animal\n   db.Where(\"name = ?\", \"galeone\").Find(&animals5)\n   fmt.Println(animals5)\n   for k, v := range animals5 {\n      fmt.Println(\"k:\", k, \"ID:\", v.ID, \"Name:\", v.Name, \"Age:\", v.Age)\n   }\n\n   //IN\n   var animals6 []Animal\n   db.Where(\"name IN (?)\", []string{\"demo-test\", \"demotest2\"}).Find(&animals6)\n   fmt.Println(animals6)\n\n   //LIKE\n   var animals7 []Animal\n   db.Where(\"name like ?\", \"%jim%\").Find(&animals7)\n   fmt.Println(animals7)\n\n   //AND\n   var animals8 []Animal\n   db.Where(\"name = ? AND age >= ?\", \"jim\", \"24\").Find(&animals8)\n   fmt.Println(animals8)\n\n   //总数\n   var count int\n   var animals9 []Animal\n   db.Where(\"name = ?\", \"galeone\").Or(\"name = ?\", \"jim\").Find(&animals9).Count(&count)\n   fmt.Println(animals9)\n   fmt.Println(count)\n\n   //Scan, 原生查询\n   var animals10 []Animal\n   db.Raw(\"SELECT id, name, age From Animals WHERE name = ? AND age = ? \", \"galeone\", \"30\").Scan(&animals10)\n   fmt.Println(\"Scan: \", animals10)\n\n   //原生查询，select all\n   var animals11 []Animal\n   rows, _ := db.Raw(\"SELECT id,name FROM Animals\").Rows()\n   //注意：上面的 select id,name 后面不能写成 * 代替，不然出来的结果都是默认0值\n   //像这样结果： ALL:  [{0  0} {0  0} {0  0} {0  0} {0  0} {0  0} {0  0}]\n   //Scan 后面是什么字段，select 后面就紧跟什么字段\n   for rows.Next() {\n      var result Animal\n      rows.Scan(&result.ID, &result.Name)\n      animals11 = append(animals11, result)\n   }\n   fmt.Println(\"ALL: \", animals11)\n   //output:ALL:  [{1 demo-test 0} {2 galeone 0} {3 demotest2 0} {4 galeone 0} {5 galeone 0} {6 jim 0} {7 jimmy 0}]\n\n   //select 查询\n   var animal12 Animal\n   db.Select(\"name,age\").Find(&animal12) //只查询name，age字段，相当于select name,age from user\n   fmt.Println(\"select: \", animal12)\n//map 结构\n    animals13:=map[int64]Animal{}\n   var animals14 []Animal\n   db.Raw(\"SELECT id, name, age From Animals WHERE id>5\").Find(&animals14)\n   for _,v:= range  animals14{\n      animals13[v.ID]=v\n   }\n   fmt.Println(animals13)\n   return nil\n}\n\nfunc update_test(db *gorm.DB)(err error){\n   //根据条件更新字段值,\n   //后面加Debug()，运行时，可以打印出sql\n   err=db.Debug().Model(&Animal{}).Where(\"id = ? \", 5).Update(\"name\", \"jimupdate\").Error\n   if err!=nil{\n      return err\n   }\n   //UPDATE `animals` SET `name` = \'jimupdate\'  WHERE (id = 4)\n\n   //另外一种写法： 根据条件更新\n   var animal Animal\n   animal = Animal{ID: 3}\n   err=db.Debug().Model(animal).Update(\"name\", \"demotest2update\").Error\n   if err!=nil{\n      return err\n   }\n   // db.Debug().Model(&animal).Update(\"name\", \"demotest2update\") // 这种写法也可以\n   //UPDATE `animals` SET `name` = \'demotest2update\'  WHERE `animals`.`id` = 3\n\n   /// 多个条件更新\n   err=db.Model(&Animal{}).Where(\"id = ? AND age = ?\", 4, 90).Update(\"name\", \"jimupdate3\").Error\n   if err!=nil{\n      return err\n   }\n   //UPDATE `animals` SET `name` = \'jimupdate2\'  WHERE (id = 4 AND age = 45)\n\n   /// 更新多个值\n   err=db.Debug().Model(&Animal{}).Where(\"id = ?\", 6).Update(Animal{Name: \"jim\", Age: 90}).Error\n   if err!=nil{\n      return err\n   }\n   // UPDATE `animals` SET `age` = 90, `name` = \'jim\'  WHERE (id = 4)\n\n   animal2 := Animal{ID: 7}\n   err=db.Debug().Model(&animal2).Update(map[string]interface{}{\"name\": \"jimm\", \"age\": 27}).Error\n   //UPDATE `animals` SET `age` = 100, `name` = \'jimm\'  WHERE `animals`.`id` = 5\n   return nil\n}\n\nfunc delet_test(db *gorm.DB)(err error)  {\n   err=db.Debug().Where(\"id = ?\", 7).Delete(&Animal{}).Error\n   if err!=nil{\n      return err\n   }\n   // DELETE FROM `animals`  WHERE (id = 13)\n   err=db.Debug().Delete(&Animal{}, \"id = ? AND age = ?\", 6, 90).Error\n   //DELETE FROM `animals`  WHERE (id = 14 AND age = 10)\n   return err\n}\nfunc trans_test(db *gorm.DB)(wrong error)  {\n   tx:=db.Begin()\n   defer func() {\n      if err:=recover(); err!=nil{\n         tx.Rollback()\n         if val,ok:=err.(error); ok{\n            wrong=val\n         }\n      } else{\n         err:=tx.Commit().Error\n         if err !=nil{\n            tx.Rollback()\n            wrong=err\n         }\n      }\n   }()\n\n   an:= Animal{Name: \"gavin\", Age: 35}\n   err:=tx.Create(&an).Error\n   if err!=nil{\n      panic(err)\n   }\n   err=tx.Exec(\"UPDATE animals SET age=40 WHERE id=1\").Error\n   if err!=nil{\n      panic(err)\n   }\n   trans_test2(tx)\n   return nil\n}\nfunc trans_test2(db *gorm.DB)  {\n   var animals1 Animal\n   //err:=db.Set(\"gorm:query_option\", \"FOR UPDATE\").Table(\"animals\").Select(\"id, `NAME`,Age\").Where(\"ID=?\",2).Find(&animals1).Error\n   err:=db.Set(\"gorm:query_option\", \"FOR UPDATE\").First(&animals1,2).Error\n   if err!=nil{\n      fmt.Println(err)\n      panic(err)\n   }\n   animals1.Name=animals1.Name +\"_ gavin update\"\n   err=db.Set(\"gorm:query_option\", \"FOR UPDATE\").Table(\"animals\").Where(\"ID=?\",2).Update(&animals1).Error\n   if err!=nil{\n      fmt.Println(err)\n      panic(err)\n   }\n}\n\n```',2,'admin',0,0,0,0,18,0,'',3,0,0,'2000-01-01 00:00:00','2022-04-22 17:57:08','2021-09-29 11:09:22'),
	(68,'依赖注入-控制反转','\n```\n\n\ninterface Base{\n    public function echo();\n}\n\nclass A implements Base{\n    public function echo(){\n        echo \"A\";\n    }\n}\n\nclass B implements Base{\n    public function echo(){\n        echo \"B\";\n    }\n\n    //该方法依赖A类\n    public function get(){\n        $m = new A(); //如果这里 逻辑特别多 还要new 其他对象的时候 \n\n        $m->echo();\n        echo \"我就想调一下A类的echo (或者该方法依赖A类) 我得在这里面new 以至于代码耦合度高\";\n    }\n}\n\n\nclass C implements Base{\n    public function echo(){\n        echo \"B\";\n    }\n\n    //该方法依赖A类\n    public function get(){\n        $m = new A(); //如果这里 逻辑特别多 还要new 其他对象的时候 \n\n        $m->echo();\n        echo \"我就想调一下A类的echo (或者该方法依赖A类) 我得在这里面new 以至于代码耦合度高\";\n    }\n}\n\n///////////依赖注入//////由外到内控制/////\nclass Y{\n    // 对比B类C类的先进之处就是多了构造类\n    // 现将对应的A B 等等只要实现了Base的类都可以注入进来\n    public function __construct(Base $base) {\n       $this->a = $base;\n    }\n\n    public function get(){\n        $this->a->echo(); //达到效果  在这里写一次就够了\n    }\n}\n\n///////////控制反转/////由内到外控制//// IOC容器控制各对象生命周期\nclass IOC {\n    public $arr = [];\n    public function __construct() {\n        $this->a = new A();\n    }\n\n    public function register($classname) {\n        $arr[$classname] = new $classname;\n    }\n\n    public function get($active){\n        $this->arr[$active]->echo(); //达到效果  在这里写一次就够了\n    }\n}\n\n\n```',2,'admin',0,0,0,0,15,0,'',3,0,0,'2000-01-01 00:00:00','2022-04-22 17:55:49','2021-10-11 00:03:26'),
	(69,'mysql知识点','# mysql 存储引擎数据结构动画效果\n\n\n### 图形化模拟数据结构   [链接地址](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)\n\n### B-Tree\n- 节点中的数据+索引从左到右递增排列\n- 所有索引元素不重复\n- 叶子节点具有相同的深度,叶子节点的指针为空\n\n### B-Plus-Tree\n- 非叶子节点不存data, 只存索引(冗余),空间用来放更多的索引\n- 叶子节点包含所有索引字段\n- 叶子节点用指针连接,提高区间访问性能\n- 叶子节点情况下 主键索引bigin8B 树末端了后面没有下级，所以省去了6B字节的指针 \n\n\n### mysql 基础常识\n\n- mysql 1 page大小16kb   通过sql语句查看  show GLOBAL STATUS like \"Innodb page size\";     \n如mysql表的主键索引 bigint 占用8B字节   +  6B 字节的指针( 树的下级节点指针)    16KB%14B = 1170 即:1个page页 可以放1170个索引节点\n高度为3的B+树 放满索引，可以放 1170*1170*16 = 2kw个索引\n\n- mysam 存储引擎表 对应三个文件 frm(表结构信息)  MYD(数据文件) MYI (索引文件)   举例: 一条sql 查询 流程 select * from t where col = 50 ;流程1.先去frm文件拿到col字段是否索引字段   2. 如果是 要去MYI文件查询索引节点为30的项.  3.找到后取该节点的下的data数据即磁盘位置指针 4.用磁盘位置去 MYD文件找到对应数据\n\n- innodb  存储引擎表对应二个文件 frm(表结构信息) ibd(数据和索引文件)   举例: 一条sql 查询 流程 select * from t where col = 50 ;流程1.先去frm文件拿到col字段是否索引字段   2. 如果是找到对应叶子节点直接取下data数据   注意点: 非主键索引如md5字符串，每个索引节点都是md5 找到叶子节点的数据data字段后拿到的是主键id 然后再通过主键找到完整的那一整条数据\n\n- 非聚集索引  MYD 与 MYI 文件分开存储, 典型代表有mysam     反之 聚集索引则是 innodb \n\n- 回表  即: mysam 一颗B+树 查到的只是磁盘位置,还要再读一次 MYD文件取数据data      反之 innodb 数据data直接 集成到叶子节点上了\n\n- 主键: innodb 表中如果没有 主键 以及 没有1列是唯一值时， innodb 会自动帮忙维护1列 主键  \n\n- hash 索引 仅仅支持 “=”   “in”  不支持范围 ， 而 b+tree 索引 可以支持 >  <  = in  等等 因为底层叶子节点从左到右 是1个递增双向链表\n\n# mysql 默认隔离级别\n\n###  知识点\n- 市面上各数据库默认事物隔离级别对比     mysql:  repeatable(可重复读)     oracle : read commited(提交后可读)   sql server : read commited(提交后可读)\n\n### 为什么mysql 默认隔离级别为 可重复读 \n- 1.早期为了保证mysql服务主从复制，采用binlog 日志，而binlog有三种格式 (statement:记录的就是sql语句，row:记录的是每行实际数据变更  mixed是statement与row混合)\n- 2.mysql5.0以前binlog只支持statement 格式，该格式 (read comment)提交后可读有bug , 主从不一致; master上执行的顺序是先删后插,而binglog-statment记录的事先插后删\n- 3.解决1. 隔离级别设为可重复读(Repeatable Read),在该隔离级别下引入间隙锁。当事物A 执行delete语句时，会锁住间隙。那么事物B执行插入语句就会阻塞住！\n- 4.解决2. binglog的格式修改为row格式，此时是基于行的复制，自然就不会出现sql执行顺序不一样的问题！奈何这个格式在mysql5.1版本开始才引入。因此由于历史原因，mysql将默认的隔离级别设为可重复读(Repeatable Read)，保证主从复制不出问题！\n- 5. 排出解决方案3  采用读未提交(Read UnCommitted),一个事务读到另一个事务未提交读数据，从逻辑上都说不过去\n- 6. 排出解决方案4 采用串行化(Serializable)，每个次读操作都会加锁，快照读失效，一般是使用mysql自带分布式事务功能时才使用该隔离级别 性能堪忧\n- 7.对比  总结\n```\n对比一\nselect * from test where id <3 for update;\n可重复读(Repeatable Read)，模式下执行该语句， 存在间隙锁，其他事务\"不可以\"插入数据！\n读已提交(Read Commited)模式下执行该语句  不存在间隙锁，其他事务可以插入数据！\n\n对比二\nupdate test set color = \'blue\' where color = \'red\'; \n可重复读(Repeatable Read)，模式下执行该语句，条件列未命中索引会锁表！\n读已提交(Read Commited)模式下执行该语句， 只锁行\n\n总结\n推荐采用 读已提交(Read Commited)隔离级别，并且设置主从复制用binlog为row格式，基于行的复制！Innodb的创始人也是建议binlog使用该格式！\n\n参考 ： https://www.cnblogs.com/shoshana-kong/p/10516404.html\n```\n\n\n#### select......for update会加锁 ，会加锁 会加锁  查询条件用了索引/主键\n\n\n',2,'admin',1,1,0,0,27,0,'',3,0,0,'2000-01-01 00:00:00','2022-04-22 17:55:33','2021-11-16 20:57:27'),
	(70,'golang','\n\n```\ngolang\n\n\n\n群里已经有的个人项目：\nhttps://github.com/SuperDraven/go-blog\nhttps://github.com/gensword/collections\nhttps://github.com/xusenlin/ForestBlog\nhttps://github.com/xusenlin/MareWood\nhttps://github.com/overtalk/shm\n\nhttps://github.com/xusenlin/hzzm(https://hz.xusenlin.com/)\n\nhttps://github.com/roseduan/rosedb\n\n比较好的一个数据结构和算法资源：\nhttps://github.com/wangzheng0822/algo\n\n\nGo开发规范：https://github.com/uber-go/guide/blob/master/style.md\n\n\n\n\n\n##gmp模型\ng表示goroutine \nm表示pthread\np表示n个队列 里面存放即将执行的协程\n\n当线程执行协程时 先从p队列获取 没有则将公共队列的协程转移到p\n(一般go运行时有 runtime.GOMAXPROCS 个p队列 即 4核CPU就是4个队列 每个队列最多放256个g 满了放公共队列，p队列空了去公共队列转移到p，m是按需自动创建)\n\n\n##关于锁\nsync mutex 是一个接口其中只有\nunlock \nlock\n任何时间点只允许1个goroutine在临界区运行\n避免死锁\n公平\n\n0值是未锁\nunlock未加锁的mutex会panic (恐慌不用recove会直接退出进程)\n加锁的mutex不和这个特定的goroutine关联\n非重入锁 (重复执行lock导致死锁)\n\n总结：\ngolang中的锁是通过CAS原子操作实现的，Mutex结构如下：\ntype Mutex struct {\nstate int32 \nsema uint32\n}\n\ngolang用的是信号量，挂起阻塞\nnginx用的是自旋锁\ntypedef struct __lock_t {\nint flag; //锁的状态 0-空闲， 1-被占用\n}lock_t; \n\nvoid init(lock_t *mutex) { //初始化锁对象\nmutex->flag = 0;\n}\n\nvoid lock(lock_t *mutex) {\nwhile(mutex->flag == 1)\n;// 自旋等待\nmutex->flag = 1;\n}\n\nvoid unlock(lock_t *mutex) {\nmutex->flag = 0;\n}\n\n##channl底层\ntype hchan struct {\nqcount uint // total data in the queue\ndataqsiz uint // size of the circular queue\nbuf unsafe.Pointer // points to an array of dataqsiz elements\nelemsize uint16\nclosed uint32\nelemtype *_type // element type\nsendx uint // send index\nrecvx uint // receive index\nrecvq waitq // list of recv waiters\nsendq waitq // list of send waiters\n\n// lock protects all fields in hchan, as well as several\n// fields in sudogs blocked on this channel.\n//\n// Do not change another G&apos;s status while holding this lock\n// (in particular, do not ready a G), as this can deadlock\n// with stack shrinking.\nlock mutex\n}\n总结：channel就是一个结构体，里面带缓冲带锁 (而且还是mutex) \n\nA. 给一个 nil channel 发送数据，造成永远阻塞\nB. 从一个 nil channel 接收数据，造成永远阻塞\nC. 给一个已经关闭的 channel 发送数据，引起 panic 重点\nD. 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值\nE.无缓冲的channel是同步的，而有缓冲的channel是非同步的；\n\n\nA. select机制用来处理异步IO问题；\nB. select机制最大的一条限制就是每个case语句里必须是一个IO操作；\nC. golang在语言级别支持select关键字；\n\n\n##切片比map(底层红黑树)性能好\n1.map 需要初始化才能使用；\n2.指针不支持索引。\ntype Param map[string]interface{}\ntype Show struct {\n*Param\n}\nfunc main() {\ns := new(Show)\np := make(Param)\np[&quot;day&quot;] = 2\ns.Param = &p\ntmp := *s.Param\nfmt.Println(tmp[&quot;day&quot;])\n}\n\n\n\n\ntime.newTimer 到时间只触发1次\ntime.newTicker 不断触发 \n\n\n关于range\nrange返回的是拷贝值！ 不是引用\nv := []int{1, 2, 3}\nfor i := range v {\nv = append(v, i)\n}\n1.循环次数在循环开始前就已经确定，循环内改变切片的长度，不影响循环次数。\n2.append后len>cap 会分新空间再将原切片内容拷过去。 (len<1024时cap两倍增加否则cap呈25%趋势增加)\n\n关于结构体\n1.结构体只能比较是否相等，但是不能比较大小。\n2.相同类型的结构体才能够进行比较\n3.如果类型实现 String() 方法，当格式化输出时会自动使用 String() 方法。String() 方法内使用格式化输出，会导致递归调用，最后抛错。\n4.不能使用短变量&quot;声明&quot;去设置结构体字段值。\ndata.result, err := work() \ndata.result, err = work()\n\n\n\n\n\n\n\n关于字符串\n1. rune 是 int32 的别名一样，byte 是 uint8 的别名，别名类型无序转换，可直接转换\n\n2. 连接strings.Join()、buffer.WriteString()等。\n\n\n3. nil 只能赋值给指针、chan、func、interface、map 或 slice 类型的变量。\n\nerror是内建类型\ntype error interface {\nError() string\n}\n\n类型选择的语法形如：i.(type)，其中 i 是接口，type 是固定关键字。\n注意：只有接口类型才可以进行类型选择。其他类型，例如 int、string等是不能的：\ntype A interface {\nShowA() int\n}\ntype B interface {\nShowB() int\n}\ntype Work struct {\ni int\n}\nfunc (w Work) ShowA() int {\nreturn w.i + 10\n}\nfunc (w Work) ShowB() int {\nreturn w.i + 20\n}\n\nfunc main() {\nvar a A = Work{3} //注意值类型实现的方法\ns := a.(Work)\nfmt.Println(s.ShowA())\nfmt.Println(s.ShowB())\n}\n\n\n形如 [i,j,k]，第三个参数 k 用来限制新切片的容量，但不能超过原数组（切片）的底层数组大小。截取获得的切片的长度和容量分别是：j-i、k-i。\n\n永远不要使用一个指针指向一个接口类型，因为它已经是一个指针。\n\n当且仅当动态值和动态类型都为 nil 时，接口类型值才为 nil\n\n按照Go语言规范，任何类型在未初始化时都对应一个零值：布尔类型是false，整型是0，字符串是&quot;&quot;，而指针，函数，interface，slice，channel和map的零值都是nil。\n\n\n函数返回值类型。nil 可以用作 interface、function、pointer、map、slice 和 channel 的“空值”。如果直接return nil，Go 语言不能识别类型，所以会报错\n\n\n如果类型定义了 String() 方法，当使用 fmt.Printf()、fmt.Print() 和 fmt.Println() 会自动使用 String() 方法，实现字符串的打印\n\n\n\n关于切片\n1.切片是不能比较的；\n\n2.字面量初始化切片时候，可以指定索引，没有指定索引的元素会在前一个索引基础之上加一。\nvar x = []int{2: 2, 3, 0: 1}\nfmt.Println(x) //[1 0 2 3]\n\n\ni++ 和 i-- 在 Go 语言中是语句，不是表达式，因此不能赋值给另外的变量。此外没有 ++i 和 --i。\n\n常量不同于变量的在运行期分配内存，常量通常会被编译器在预处理阶段直接展开，作为指令数据使用，所以常量无法寻址。\n\n\n\n\n\n\n```',2,'admin',1,1,0,0,15,0,'',3,0,0,'2000-01-01 00:00:00','2022-04-22 12:05:46','2021-12-31 22:40:38'),
	(71,'路上追尾   被撞   发生交通事故等 处理流程','# 汽车发生交通事故的处理流程如下：\n- 1、保护现场，不要挪动车辆和受伤人员；\n-  2、初步判断现场责任；\n-  3、打122交警电话进行报警；\n-  4、全责方致电自己的保险公司出险；\n-  5、双方协调是否需要快速理赔；\n-  6、如果警察出警，留好事故责任认定书；\n- 7、如果协商赔偿或快速理赔，一定要对方留下押金，现金最好，驾驶证副本互换也可；\n-  8、保证自己手续齐全的情况下，尽量不要私了\n-  9、弄不清事故造成的经济损失时，致电购车的4s店，询问工作人员。\n',2,'admin',0,0,0,0,6,0,'',1,0,0,'2000-01-01 00:00:00',NULL,'2021-12-31 22:46:07'),
	(72,'问牙医  一个科普牙科知识的网站',' \n问牙医 \nhttps://askthedentist.com/\n一个科普牙科知识的网站\n\n一个在线文献库 \nhttps://onlinelibrary.wiley.com/\nWiley是指1807年创立于美国的一个数据库， 是全球历史最悠久﹑最知名的学术出版商之一，享有世界第一大独立的学术图书出版商和第三大学术期刊出版商的美誉。\n',2,'admin',0,0,0,0,8,0,'',1,0,0,'2000-01-01 00:00:00',NULL,'2021-12-31 22:58:09'),
	(73,'查看进程，按内存从大到小','```\n查看进程，按内存从大到小 \n[root@iZwz9 src]# ps -e -o \"%C : %p : %z : %a\"|sort -k5 -nr\n\n\n查看进程，按CPU利用率从大到小排序\n [root@iZwz9 src]#ps -e -o \"%C : %p : %z : %a\"|sort -nr查看剩余内存 [root@iZwz9 src]#free -m |grep \"Mem\" | awk \"{print $2}\"\n\n\n\n\n\n\n\n\nkeep-alive分 tcp 和 http 两种 \n\n\n系统级别:\necho 1800 > /proc/sys/net/ipv4/tcp_keepalive_time echo 15 > /proc/sys/net/ipv4/tcp_keepalive_intvl echo 5 > /proc/sys/net/ipv4/tcp_keepalive_probes 以上shell命令表示: keepalive是TCP保鲜定时器，当网络两端建立了TCP连接之后，持续1800秒没有数据流发送往来，此时server主动向client发送侦测包,每隔15秒1次,共5次； 直到收到对方的ack；\n\n\n\nnginx 即可以设置tcp层的keepalive 又可以设置http层的keepalive\n如:\n\n\nlisten 80 default so_keepalive=3s:5s:8;  \n表示连接成功后,持续3秒任然没有数据流往来，server主动向client发送侦测包，每隔5秒1次,共8次\n\n\n\nkeepalive_timeout 75s 300s; server发送响应结果后 再维持连接75s才断开连接 keepalive_requests 8192; 一次连接最多只能请求8129次； \n\n\n\n\n\n centos 6.5 下载地址 \nhttps://archive.kernel.org/centos-vault/6.5/isos/x86_64/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nopenSSH升级\n###########centos6.5 openssh 升级\nhttp://blog.csdn.net/levy_cui/article/details/53100315\nhttp://blog.csdn.net/songzhusheren/article/details/53167008\n\n前提：\nyum install zlib-devel\nyum install openssl-devel\nyum -y install pam-devel\n\ncp -R /etc/ssh /etc/ssh_bak \n或者\nmv /etc/ssh /etc/ssh2 \n\ncp /root/openssh-7.6p1/contrib/redhat/sshd.init /etc/init.d/sshd\ncp /usr/bin/ssh /usr/bin/ssh-backup\ncp /usr/sbin/sshd /usr/sbin/sshd-backup\n\n\nhttp://ftp.openbsd.org/pub/OpenBSD/OpenSSH/portable/\n\ntar -zxvf openssh-7.6p1.tar.gz \ncd openssh-7.6p1\n./configure --prefix=/usr --sysconfdir=/etc/ssh --with-pam --with-zlib --with-md5-passwords --with-tcp-wrappers\nmake && make install \n/etc/init.d/sshd restart\n或者\nsystemctl restart sshd.service\nsystemctl list-unit-files|grep sshd.service\n防止登录不上\nyum install telnet-server\n\nvi /etc/xinetd.d/telnet\nservice telnet\n{\nflags = REUSE\nsocket_type = stream\nwait = no\nuser = root\nserver = /usr/sbin/in.telnetd\nlog_on_failure += USERID\ndisable = no\n}\n\n默认不允许root登录\n\nvi /etc/securetty\n增加\npts/0\npts/1\npts/2\n如果登录用户较多，需要更多的pts/*\n\n/etc/init.d/xinetd restart\n这样root可以telnet登录了\n\nssh升级后建议再修改回还原设置\n\n\n\n\nyum remove telnet-server\n\n\n```',2,'admin',0,0,0,0,12,0,'',3,0,0,'2000-01-01 00:00:00','2022-04-22 17:56:23','2021-12-31 22:59:31'),
	(74,'问题.肉眼看到的图形是如何对应十六进制的','```\n问题.肉眼看到的图形是如何对应十六进制的\n在fiddler中 点击左侧的链接，点击右侧inspectors->textview->hexview，可以看到16进制, 这个怎么对应识别\n如.选中对应乱码右侧会跟随选中， 比如选中 0 对应十六进制 30 其中这个30到底怎么来\n\n回答.\n首先与乱码对应的是128位 ASCII码 (注意它有33个不可打印字符(如控制字符回车,换行等) + 95个可打印字符)\n图形数字0在ASCII码中对应的 十进制位置是48 十六进制则是30 (30则与之对应)\n图形大写M在ASCII码中对应的 十进制位置是77 十六进制则是4D\n\n\n\n\n```',2,'admin',0,0,0,0,13,0,'',3,0,0,'2000-01-01 00:00:00','2022-04-22 17:56:12','2021-12-31 23:12:48'),
	(75,'前端面试题','```\n\n\n前端面试题:\n1.cookie session 区别,优缺点？\n\n2.解释下盒子模型？\n\n3.标签选择器有哪些？\n\n4.call 和 apply 的作用与区别？\n\n5.url参数乱码问题如何解决？\n\n6.下面代码输出什么？\nfunction A() {\n    getName = function () { \n        console.log(&apos;1&apos;);\n    };\n    return this;\n};\nA.getName = function () {\n    console.log(&apos;2&apos;);\n};\nA.prototype.getName = function () { \n    console.log(&apos;3&apos;);\n};\nvar getName = function () {\n    console.log(&apos;4&apos;);\n};\nfunction getName() { \n    console.log(&apos;5&apos;);\n};\nA.getName(); \ngetName(); \nA().getName(); \ngetName(); \nnew A.getName(); \nnew A().getName();\n\n\n```',2,'admin',0,0,0,0,14,0,'',3,0,0,'2000-01-01 00:00:00','2022-04-22 17:58:31','2021-12-31 23:17:10'),
	(77,'golang   字符串    二进制字符转换单个字符输出','# golang   二进制字符转换单个字符输出\n\n\n### OpenResty Con 2017 中的一个彩蛋\n\n- lua版 源地址转 https://ms2008.github.io/2019/01/02/openresty-easter-egg/\n\n\n## 最近项目中遇到了,于是写了个golang版本 字符串二进制字符 转换 单个字符输出\n\n\n```\n\n\npackage main\n\nimport (\n    \"fmt\"\n    \"strconv\" \n)\n\nfunc main() {\n	binStr := \"01110111011001010110110001100011011011110110110101100101\"\n        dst := make([]string,0)\n	for i:=0; i< len(binStr); i = i+8 {\n		t := binStr[i:i+8]\n\n		 // 每行输出 1个字节 (即8个位 或者叫 8个 0和1组成的字符串)  \n		fmt.Println(t) \n		// 将每个字节 解析成 32位十进制数\n		tmp, _ := strconv.ParseInt(t, 2, 32) \n           \n		// 将32位十进制数 转换为单个字符  然后追加到切片中\n		dst = append(dst, fmt.Sprintf(\"%c\", tmp)) \n	}\n	fmt.Println(dst) // [w e l c o m e   t o   t h e   f u t u r e]\n}\n```',2,'admin',0,0,0,0,5,0,'',3,0,0,'2000-01-01 00:00:00','2022-04-22 12:43:41','2022-04-22 12:34:40'),
	(78,'golang   net/http 源码执行流程','# golang net/http 源码执行流程\n\n## net/http 优势\n- 跨平台\n- 简洁、大众化 所有golang开发都会使用 且(可定制化路由)\n- 维护成本低且属于golang标准库\n\n\n## net/http 默认情况下的不足 \n- 不能单独的对请求方法(POST,GET等)注册特定的处理函数\n- 不支持Path变量获取参数 \n\n## 使用案例\n``` \n使用案例一:\nfunc main{\n    http.HandleFunc(\"/api/goods/info\", c.GoodsInfo)\n    http.Handle(\"/api/order/list\", c.Middleware(http.HandlerFunc(c.OrderList)))\n    http.ListenAndServe(\"0.0.0.0:8080\", nil) //设置监听的端口\n}\n\n使用案例二:\nfunc main{\n    type router struct {} \n    func (ro *router) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n        switch r.URL.Path {\n        case \"/ping\": \n            w.Write([]byte(`pong`))\n        default:\n            w.WriteHeader(http.StatusNotFound)\n        }\n    }\n    err := http.ListenAndServe(\"0.0.0.0:8080\", &router{}) //设置路由和监听的端口\n}\n\n使用案例三:\nfunc main{\n    http.HandleFunc(\"/api/test\", c.GoodsInfo)\n    http.Handle(\"/ping\", c.Middleware(http.HandlerFunc(c.Ping)))\n    srv := http.Server{\n        Addr:    \"0.0.0.0:8080\",\n        Handler: http.DefaultServeMux, //上面所有api路由(/ping,/api/test)全都在该全局结构体指针的m属性上\n    }\n    err := srv.ListenAndServe() //设置监听的端口\n    ....\n}\n```\n\n## 源码分析  \n\n### 第一步: 注册路由\n``` \n// 定义1个接口   (路由结构体必须实现 ServeHTTP 方法)\ntype Handler interface {\n    ServeHTTP(ResponseWriter, *Request)\n}\n\n // 这一步极为重要 开始就定义了1个全局\"路由结构体指针\", 这才有了 使用案例一 使用案例三 的操作\nvar DefaultServeMux = &defaultServeMux \ntype ServeMux struct {\n    mu    sync.RWMutex\n    m     map[string]muxEntry\n    es    []muxEntry // 从最长到最短排序的条目的切片。\n    hosts bool // whether any patterns contain hostnames\n}\n\nvar defaultServeMux ServeMux  //默认的 DefaultServeMux 路由的\n\nfunc Handle(pattern string, handler Handler) { \n    DefaultServeMux.Handle(pattern, handler) \n}\n\nfunc HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n    DefaultServeMux.HandleFunc(pattern, handler)  //DefaultServeMux.HandleFunc 函数最终会调用 ServeMux.Handle函数。\n}\n\nfunc (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n    mux.Handle(pattern, HandlerFunc(handler)) //为给定的模式注册处理程序函数\n}\n\nfunc (mux *ServeMux) Handle(pattern string, handler Handler) {\n    //省略加锁和判断代码 \n    //把我们注册的路径和相应的处理函数存入了m字段中\n    mux.m[pattern] = muxEntry{h: handler, pattern: pattern} \n    if pattern[0] != \'/\' {\n        mux.hosts = true\n    }\n}\n\nfunc (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {\n    //省略一些无关代码\n    h, _ := mux.Handler(r) // h是1个新的结构体并且实现了接口 Handler\n    h.ServeHTTP(w, r)\n}\n``` \n\n\n### 第二步: 创建 绑定 监听 \n``` \nserver.go\ntype Server struct {\n    Addr string\n    Handler Handler   // 这一步极为重要 路由结构体 被赋值过来\n    .....\n}\n\n// 监听端口\n//  func ListenAndServe(addr string, handler Handler) error {...} 等同于下面\nfunc (srv *Server) ListenAndServe() error {\n    ln, err := net.Listen(\"tcp\", srv.Addr)\n    return srv.Serve(ln)\n}\n// 接收连接请求 并读取连接中的头\nfunc (srv *Server) Serve(l net.Listener) error {\n    for {\n        ....\n        rw, err := l.Accept()\n        c := srv.newConn(rw)\n        go c.serve(connCtx) //执行 结构体 下的serve 方法\n    }\n} \nfunc (srv *Server) newConn(rwc net.Conn) *conn {\n    c := &conn{ \n        server: srv, // 创建1个连接结构体,  srv赋值进去了.   注意srv.Handler.m这个map里面放的是注册好的路由\n        rwc:    rwc,\n    }\n    return c\n}\n\n// 处理一个新的连接\nconn 结构体 \nfunc (c *conn) serve(ctx context.Context) {\n    for {\n        w, err := c.readRequest(ctx) //return *response, error\n        serverHandler{c.server}.ServeHTTP(w, w.req) // 这一步极为重要 表示程序源码结尾\n    }\n}\n\n``` \n\n\n### 第三步：源码结尾 (路由结构体的 ServeHTTP 方法被调用) \n``` \ntype serverHandler struct {\n    srv *Server  \n}\nfunc (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {\n    handler := sh.srv.Handler // 注意 注意 注意 handler 这个就路由结构体, srv 对应第二步 Server 结构体\n    if handler == nil {\n        handler = DefaultServeMux  // 这个变量是不是很熟悉 就是 第一步 中的全局路由结构体指针\n    }\n    if req.RequestURI == \"*\" && req.Method == \"OPTIONS\" {\n        handler = globalOptionsHandler{}\n    }\n    handler.ServeHTTP(rw, req) //这里则是 调用了第一步 路由结构体的 ServeHTTP 方法\n}\n\n```\n',2,'admin',0,0,0,0,4,0,'',3,1,0,'2000-01-01 00:00:00',NULL,'2022-04-22 12:38:06'),
	(79,'golang   c/c++  lua    tea 加解密算法','# golang c/c++ lua 三个版本 tea 加解密\n\n## golang 版本\n```\npackage main\n\nimport (\n	\"bytes\"\n	\"encoding/binary\"\n	\"fmt\" \n	\"crypto/cipher\"\n	\"errors\"\n)\nconst (\n	BlockSize = 8\n	KeySize = 16\n	delta = 0x9e3779b9\n 	numRounds = 64\n)\ntype tea struct {\n	key    [16]byte\n	rounds int\n}\nfunc NewCipher(key []byte) (cipher.Block, error) {\n	return NewCipherWithRounds(key, numRounds)\n}\nfunc NewCipherWithRounds(key []byte, rounds int) (cipher.Block, error) {\n	if len(key) != 16 {\n		return nil, errors.New(\"tea: incorrect key size\")\n	}\n\n	if rounds&1 != 0 {\n		return nil, errors.New(\"tea: odd number of rounds specified\")\n	}\n\n	c := &tea{\n		rounds: rounds,\n	}\n	copy(c.key[:], key)\n\n	return c, nil\n}\nfunc (*tea) BlockSize() int {\n	return BlockSize\n}\nfunc (t *tea) Encrypt(dst, src []byte) {\n	e := binary.BigEndian\n	v0, v1 := e.Uint32(src), e.Uint32(src[4:])\n	k0, k1, k2, k3 := e.Uint32(t.key[0:]), e.Uint32(t.key[4:]), e.Uint32(t.key[8:]), e.Uint32(t.key[12:])\n\n	sum := uint32(0)\n	delta := uint32(delta)\n\n	for i := 0; i < t.rounds/2; i++ {\n		sum += delta\n		v0 += ((v1 << 4) + k0) ^ (v1 + sum) ^ ((v1 >> 5) + k1)\n		v1 += ((v0 << 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3)\n	}\n\n	e.PutUint32(dst, v0)\n	e.PutUint32(dst[4:], v1)\n}\nfunc (t *tea) Decrypt(dst, src []byte) {\n	e := binary.BigEndian\n	v0, v1 := e.Uint32(src), e.Uint32(src[4:])\n	k0, k1, k2, k3 := e.Uint32(t.key[0:]), e.Uint32(t.key[4:]), e.Uint32(t.key[8:]), e.Uint32(t.key[12:])\n\n	delta := uint32(delta)\n	sum := delta * uint32(t.rounds/2) // in general, sum = delta * n\n\n	for i := 0; i < t.rounds/2; i++ {\n		v1 -= ((v0 << 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3)\n		v0 -= ((v1 << 4) + k0) ^ (v1 + sum) ^ ((v1 >> 5) + k1)\n		sum -= delta\n	}\n\n	e.PutUint32(dst, v0)\n	e.PutUint32(dst[4:], v1)\n}\n\nfunc TestTeaDemo() {\n	key := []byte(\"hello world! ...\") //长度必须为16byte\n	c, err := NewCipherWithRounds(key, 8)\n	if err != nil {\n		fmt.Println(\"失败:1\")\n		return\n	}\n	raw := []byte(\"hello...\") //长度必须为8byte\n	dst := make([]byte, 8)    //长度必须为8byte\n	c.Encrypt(dst, raw)\n\n	raw2 := make([]byte, 8) //长度必须为8byte\n	c.Decrypt(raw2, dst[:])\n\n	if !bytes.Equal(raw, raw2) { \n		fmt.Println(\"失败:2\")\n		return\n	}\n\n	fmt.Println(\"文1:\", (raw))\n	fmt.Println(\"文2:\", (raw2))\n}\n \n\nfunc main() {\n	// 加密 \n	TestTeaDemo()\n}\n\n// teax 参考 https://mojotv.cn/     https://github.com/mojocn/alg-tea/blob/master/tea_test.go\n\n\n```\n\n\n## c/c++版本\n\n```\n\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#ifndef DD_LOG\n#define DD_LOG 1\n#define dd(...) fprintf(stderr, \"c *** %s: \", __func__); \\\n            fprintf(stderr, __VA_ARGS__); \\\n            fprintf(stderr, \" at %s line %d.\\n\", __FILE__, __LINE__)\n#endif\n\n#define TEA_ENCRYPT true\n#define TEA_DECRYPT false\n\n\nvoid rc4(char * pass, char* data, int data_length)\n{\n	int a, i, j, k, tmp, pwd_length;\n\n	pwd_length = strlen(pass);\n\n	int key[256];\n	int box[256];\n	//CString cipher;\n	for (i = 0; i < 256; i++)\n	{\n		key[i] = pass[i % pwd_length];\n		box[i] = i;\n	}\n	for (j = i = 0; i < 256; i++)\n	{\n		j = (j + box[i] + key[i]) % 256;\n		tmp = box[i];\n		box[i] = box[j];\n		box[j] = tmp;\n	}\n	for (a = j = i = 0; i < data_length; i++)\n	{\n		a = (a + 1) % 256;\n		j = (j + box[a]) % 256;\n		tmp = box[a];\n		box[a] = box[j];\n		box[j] = tmp;\n		k = box[((box[a] + box[j]) % 256)];\n		//cipher[i] = (data[i]) ^ k;\n		data[i] ^= k;\n	}\n}\n\nint VerifyKey(char *strText,char *strKey)\n{\n	char str[50] = { \"0\" };\n	str[0] = strText[8];\n	str[1] = strText[13];\n	str[2] = strText[18];\n	str[3] = strText[21];\n	str[4] = strText[24];\n	str[5] = strText[27];\n	str[6] = strText[30];\n	str[7] = strText[33];\n	str[8] = strText[36];\n	return strcmp(strKey, str);\n}\n \n\n\n\n\n//解密函数  \nvoid tea_decrypt (uint32_t* v ) {\n  uint32_t tmp[4] = {0x4cae669b, 0x5fac5ef9, 0xd818b87a, 0xf17a4e9c};\n  uint32_t* k = tmp;\n\n    uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i;  \n    uint32_t delta=0x9e3779b9; \n    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; \n \n    for (i=0; i<32; i++) { \n        v1 -= ((v0<<4) + k2) ^ (v0 + sum) ^ ((v0>>5) + k3);  \n        v0 -= ((v1<<4) + k0) ^ (v1 + sum) ^ ((v1>>5) + k1);  \n        sum -= delta; \n    } \n    v[0]=v0; v[1]=v1;  \n}\n\n \n//加密函数  \nvoid tea_encrypt (uint32_t* v) {\n	uint32_t tmp[4] = {0x4cae669b, 0x5fac5ef9, 0xd818b87a, 0xf17a4e9c};\n	uint32_t* k = tmp;\n\n    uint32_t v0=v[0], v1=v[1], sum=0, i; \n    uint32_t delta=0x9e3779b9; \n    uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; \n    for (i=0; i < 32; i++) { \n        sum += delta; \n        v0 += ((v1<<4) + k0) ^ (v1 + sum) ^ ((v1>>5) + k1);  \n        v1 += ((v0<<4) + k2) ^ (v0 + sum) ^ ((v0>>5) + k3);  \n    } \n    v[0]=v0; v[1]=v1;  \n}\n \nint tea_crypt(char *req,uint32_t req_len,bool crypt_method)\n{\n   int nret = 0;\n  uint32_t *msg_ptr = (uint32_t*)req;\n  if(crypt_method == TEA_ENCRYPT)\n  {\n    for(int i=0;i<(req_len/8);i++)\n    {\n      tea_encrypt(&msg_ptr[i*2]);\n    }\n  }\n  else\n  {\n    for(int i=0;i<(req_len/8);i++)\n    {\n      uint32_t v[2];\n      v[0] = msg_ptr[i*2];\n      v[1] = msg_ptr[(i*2)+1];\n      tea_decrypt(v);\n      msg_ptr[i*2] = v[0];\n      msg_ptr[(i*2)+1] = v[1];\n    }\n    nret = req_len - req[req_len - 1];\n  }\n  return nret;\n}\n\n```\n\n\n## lua 版本 \n\n``` \nlocal bit = require(\"bit\")\nlocal tea_encrypt =function (v)\n  local sum = 0\n  local delta = 0x9e3779b9\n  local i = 0\n  local v0=v[1]\n  local v1=v[2]\n  local k0=0x4cae669b\n  local k1=0x5fac5ef9\n  local k2=0xd818b87a\n  local k3=0xf17a4e9c\n  local cal1,cal2,cal3,cal4\n  for i=1,32,1 do\n    sum = sum + delta\n    cal1 = bit.lshift(v1,4) + k0\n    cal2 = v1 + sum\n    cal3 = bit.rshift(v1,5) + k1\n    cal4 = bit.bxor(cal1,cal2,cal3)\n    v0 = v0 + cal4\n    v0 = bit.band(v0,0xFFFFFFFF)\n    \n    cal1 = bit.lshift(v0,4) + k2\n    cal2 = v0 + sum\n    cal3 = bit.rshift(v0,5) + k3\n    cal4 = bit.bxor(cal1,cal2,cal3)\n    v1 = v1 + cal4\n    v1 = bit.band(v1,0xFFFFFFFF)\n  end\n\n  v[1] = v0\n  v[2] = v1\n\nend\n\nlocal tea_decrypt = function (v)\n  local sum = 0xC6EF3720\n  local delta = 0x9e3779b9\n  local i = 0\n  local cal1,cal2,cal3,cal4\n  local v0=v[1]\n  local v1=v[2]\n  local k0=0x4cae669b\n  local k1=0x5fac5ef9\n  local k2=0xd818b87a\n  local k3=0xf17a4e9c\n\n  for i=1,32,1 do\n    cal1 = bit.lshift(v0,4) + k2\n    cal2 = v0 + sum\n    cal3 = bit.rshift(v0,5) + k3\n    cal4 = bit.bxor(cal1,cal2,cal3)\n    v1 = v1 - cal4\n    v1 = bit.band(v1,0xFFFFFFFF)\n\n    cal1 = bit.lshift(v1,4) + k0\n    cal2 = v1 + sum\n    cal3 = bit.rshift(v1,5) + k1\n    cal4 = bit.bxor(cal1,cal2,cal3)\n    v0 = v0 - cal4\n    v0 = bit.band(v0,0xFFFFFFFF)\n\n    sum = sum - delta\n  end\n\n  v[1] = v0\n  v[2] = v1\nend\n\n\nlocal dump = function (v)\n  local __dump\nif not __dump then\n  __dump = function (v, t, p)    \n    local k = p or \"\";\n\n    if type(v) ~= \"table\" then\n      table.insert(t, k .. \" : \" .. tostring(v));\n    else\n      for key, value in pairs(v) do\n        __dump(value, t, k .. \"[\" .. key .. \"]\");\n      end\n    end\n  end\nend\n\nlocal t = {\'======== Lib:Dump Content ========\'};\n__dump(v, t);\nprint(table.concat(t, \"\\n\"));\nend\n\n\nlocal from_hex = function(s) \n  local _byte_from_hex = function(x) \n      return string.char(tonumber(x, 16)) \n  end \n  return (s:gsub(\"(..)\", _byte_from_hex))\nend\n\n\nlocal to_hex = function(s)\n  local _byte_to_hex = function(x)\n    return string.format(\"%02x\", x:byte())\n  end\n  return (s:gsub(\"(.)\", _byte_to_hex))\nend\n\nlocal swap32 = function(s) \n	return bit.lshift(bit.band(s,0x000000FF),24) + bit.lshift(bit.band(s,0x0000FF00),8) + bit.rshift(bit.band(s,0xFF000000),24) + bit.rshift(bit.band(s,0x00FF0000),8)\nend\n\n\nlocal ngx_string = require \"resty.string\"\n\nlocal _M = {}\n \n--- 调用  data =  _M:decrypt(data, false)\n-- 参数1 接收数据  参数2 加密/或者解密\nfunction _M:decrypt(body, typ) \n    body = ngx_string.to_hex(body)\n    local v={} \n    local body_len = #body\n    if body_len < 1 then\n        return \"\"\n    end\n    \n    local dec_str=\"\"\n    for i=1, body_len/16, 1 do\n      v[1] = swap32(tonumber(string.sub(body , 1+(i-1)*16 , 1+(i-1)*16+8-1),16))\n      v[2] = swap32(tonumber(string.sub(body , 1+(i-1)*16+8 , 1+(i-1)*16+16-1),16))\n  \n      tea_decrypt(v)\n      \n      dec_str = dec_str .. string.char(\n        bit.band(bit.rshift(v[1],0),0xFF),\n        bit.band(bit.rshift(v[1],8),0xFF),\n        bit.band(bit.rshift(v[1],16),0xFF),\n        bit.band(bit.rshift(v[1],24),0xFF),\n        bit.band(bit.rshift(v[2],0),0xFF),\n        bit.band(bit.rshift(v[2],8),0xFF),\n        bit.band(bit.rshift(v[2],16),0xFF),\n        bit.band(bit.rshift(v[2],24),0xFF))\n    end\n    \n    return dec_str\nend\n\nreturn _M\n``` ',2,'admin',0,0,0,0,7,0,'',3,0,0,'2000-01-01 00:00:00','2022-04-22 16:33:24','2022-04-22 16:20:27'),
	(80,'etcd 安装 学习 使用','## etcd 学习使用笔记\n\n```\n\netcd 集群\nhttps://www.cntofu.com/book/139/etcd/cluster.md\nhttps://www.cnblogs.com/skymyyang/p/10576278.html   参考地址\n\n\n\n#########docker 方式安装#############\ndocker run --name etcd1 -d -p 2379:2379  -p 2380:2380 -v /Users/luoyuxiang/.laradock/data/etcd:/var/etcd -v /etc/localtime:/etc/localtime registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:3.2.24 etcd --name etcd-s1 --auto-compaction-retention=1 --data-dir=/var/etcd/etcd-data  --listen-client-urls http://0.0.0.0:2379  --listen-peer-urls http://0.0.0.0:2380  --initial-advertise-peer-urls http://192.168.83.165:2380  --advertise-client-urls http://192.168.83.165:2379,http://192.168.83.165:2380 -initial-cluster-token etcd-cluster  -initial-cluster \"etcd-s1=http://192.168.83.165:2380,etcd-s2=http://192.168.83.165:2480,etcd-s3=http://192.168.83.165:2580\" -initial-cluster-state new\n\ndocker run --name etcd2 -d -p 2479:2379  -p 2480:2380 -v /Users/luoyuxiang/.laradock/data/etcd2:/var/etcd -v /etc/localtime:/etc/localtime registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:3.2.24 etcd --name etcd-s2 --auto-compaction-retention=1 --data-dir=/var/etcd/etcd-data  --listen-client-urls http://0.0.0.0:2479  --listen-peer-urls http://0.0.0.0:2480  --initial-advertise-peer-urls http://192.168.83.165:2480  --advertise-client-urls http://192.168.83.165:2479,http://192.168.83.165:2480 -initial-cluster-token etcd-cluster  -initial-cluster \"etcd-s1=http://192.168.83.165:2380,etcd-s2=http://192.168.83.165:2480,etcd-s3=http://192.168.83.165:2580\" -initial-cluster-state new\n\n\n########进入镜像 查看集群状态########\n/ # etcdctl --endpoints=http://192.168.83.165:2379,http://192.168.83.165:2479 member list \n\ndf339c03e281023: name=etcd-s1 peerURLs=http://192.168.83.165:2380 clientURLs=http://192.168.83.165:2379,http://192.168.83.165:2380 isLeader=true\n4087e512fb03a648: name=etcd-s3 peerURLs=http://192.168.83.165:2580 clientURLs= isLeader=false\n68cbc22003188bb9: name=etcd-s2 peerURLs=http://192.168.83.165:2480 clientURLs=http://192.168.83.165:2479,http://192.168.83.165:2480 isLeader=false\n\n\n#############测试######\n# export ETCDCTL_API=3; etcdctl-3.2.24 --endpoints=http://192.168.83.165:2379,http://192.168.83.165:2479 --write-out=\"simple\" put foo \"hello world\" \n\n# export ETCDCTL_API=3; etcdctl-3.2.24 --endpoints=http://192.168.83.165:2379,http://192.168.83.165:2479 --write-out=\"simple\" get f --prefix --keys-only\n\n# export ETCDCTL_API=3; etcdctl-3.2.24 --endpoints=http://192.168.83.165:2379,http://192.168.83.165:2479 --write-out=\"simple\" get foo\n\n# export ETCDCTL_API=3; etcdctl-3.2.24 --endpoints=http://192.168.83.165:2379,http://192.168.83.165:2479 --write-out=\"simple\" del foo --from-key=true\n\n# export ETCDCTL_API=3; etcdctl-3.2.24 --endpoints=http://192.168.83.165:2379,http://192.168.83.165:2479 --write-out=\"simple\"  get g --prefix --keys-only\n\ngoim:///connectint_grpc_service/192.168.83.165:50000\ngoim:///connectint_grpc_service/192.168.83.165:50002\ngoim:///logicint_grpc_service/192.168.83.165:50100\ngoim:///logicint_grpc_service/192.168.83.165:50102\n\n\n\n\n\n\n\n\n\n\n\n\n\n#####安装####\ngit clone https://github.com/coreos/etcd.git\ncd etcd/ \n./build \ngo get go.etcd.io/etcd \n./build  \ngo run main.go \n\n[root@node222 etcd]# vi /etc/profile\nexport PATH=/usr/local/etcd:$PATH\nexport ETCDCTL_API=3\n\n\n[root@node222 etcd]# mkdir /data/db/etcd/cd0  /data/db/etcd/cd1 /data/db/etcd/cd2 -p \n\n##更多参数 参考https://www.cnblogs.com/lowezheng/p/10307592.html\n##https://skyao.gitbooks.io/learning-etcd3/documentation/op-guide/clustering.html\n#####启动####\n[root@node222 etcd]# etcd --name cd0 \\\n  --data-dir=/data/db/etcd/cd0 \\\n  --initial-advertise-peer-urls http://127.0.0.1:2380 \\\n  --listen-peer-urls http://127.0.0.1:2380 \\\n  --listen-client-urls http://192.168.3.222:2379,http://127.0.0.1:2379 \\\n  --advertise-client-urls http://192.168.3.222:2379,http://127.0.0.1:2379 \\\n  --initial-cluster-token etcd-cluster-1 \\\n  --initial-cluster cd0=http://127.0.0.1:2380,cd1=http://127.0.0.1:2480,cd2=http://127.0.0.1:2580 \\\n  --initial-cluster-state new\n \n \n[root@node222 etcd]# etcd --name cd1 \\\n  --data-dir=/data/db/etcd/cd1 \\\n  --initial-advertise-peer-urls http://127.0.0.1:2480 \\\n  --listen-peer-urls http://127.0.0.1:2480 \\\n  --listen-client-urls http://192.168.3.222:2479,http://127.0.0.1:2479 \\\n  --advertise-client-urls http://192.168.3.222:2479,http://127.0.0.1:2479 \\\n  --initial-cluster-token etcd-cluster-1 \\\n  --initial-cluster cd0=http://127.0.0.1:2380,cd1=http://127.0.0.1:2480,cd2=http://127.0.0.1:2580 \\\n  --initial-cluster-state new\n \n \n \n[root@node222 etcd]# etcd --name cd2 \\\n  --data-dir=/data/db/etcd/cd2 \\\n  --initial-advertise-peer-urls http://127.0.0.1:2580 \\\n  --listen-peer-urls http://127.0.0.1:2580 \\\n  --listen-client-urls http://192.168.3.222:2579,http://127.0.0.1:2579 \\\n  --advertise-client-urls http://192.168.3.222:2579,http://127.0.0.1:2579 \\\n  --initial-cluster-token etcd-cluster-1 \\\n  --initial-cluster cd0=http://127.0.0.1:2380,cd1=http://127.0.0.1:2480,cd2=http://127.0.0.1:2580 \\\n  --initial-cluster-state new\n \n\n--name 节点名称\n--data-dir 数据存储目录\n--wal-dir 存放预写式日志,最大的作用是记录了整个数据变化的全部历程\n--snapshot-count 数据快照触发数量,etcd处理指定的次数的事务提交后，生产数据快照\n--heartbeat-interval 客户端连接后的心跳间隔（毫秒）\n--election-timeout 集群选举的超时时间\n--listen-peer-urls 本节点与其他节点进行数据交换(选举，数据同步)的监听地址 可以多个并用逗号隔开，如果配置是http://0.0.0.0:2379,将不限制node访问地址\n--listen-client-urls 本节点访问地址 可以多个并用逗号隔开，如果配置是http://0.0.0.0:2379,将不限制node访问地址\n--max-snapshots  最大快照数量 0表示不限制,在window平台设置无效\n--max-wals 最大预写日志数量 0表示不限制,在window平台设置无效。\n--cors   用逗号分隔的CORS(跨源资源共享)白色源列表。 \n\n--initial-advertise-peer-urls  其他节点与本节点进行数据交换（选举，同步）的地址，URL可以使用domain地址。 \n--listener-peer-urls 用于请求客户端的接入控制，initial-advertise-peer-urls是告知其他集群节点访问哪个URL，一般来说，initial-advertise-peer-urlsl将是listener-peer-urls的子集\n--initial-cluster 集群所有节点配置，多个用逗号隔开。\n--initial-cluster-state 节点初始化方式，new 表示如果没有集群不存在，创建新集群，existing表示如果集群不存在，节点将处于加入集群失败状态。\n--initial-cluster-token 集群唯一标识，相同标识的节点将视为在一个集群内。\n--advertise-client-urls 用于通知其他ETCD节点，客户端接入本节点的监听地址，一般来说advertise-client-urls是listen-client-urls子集\n--discovery  集群发现服务地址\n--discovery-srv DNS发现服务地址\n\n\n\n1. --auto-compaction-retention\n由于ETCD数据存储多版本数据，随着写入的主键增加历史版本需要定时清理，　默认的历史数据是不会清理的，数据达到2G就不能写入，必须要清理压缩历史数据才能继续写入；\n所以根据业务需求，在上生产环境之前就提前确定，历史数据多长时间压缩一次；　我们的生产环境现在升级后是默认一小时压缩一次数据。这样可以极大的保证集群稳定，减少内存和磁盘占用\n\n\n2.--max-request-bytes\netcd Raft消息最大字节数，ETCD默认该值为1.5M; 但是很多业务场景发现同步数据的时候1.5M完全没法满足要求，所以提前确定初始值很重要；　由于1.5M导致我们线上的业务无法写入元数据的问题，\n我们紧急升级之后把该值修改为默认32M,但是官方推荐的是10M，大家可以根据业务情况自己调整\n\n\n3.--quota-backend-bytes\nETCDdb数据大小，默认是２G,当数据达到２G的时候就不允许写入，必须对历史数据进行压缩才能继续写入；　参加1里面说的，我们启动的时候就应该提前确定大小，官方推荐是8G,这里我们也使用8G的配置\n \n /usr/bin/etcd --auto-compaction-retention \'1\' --max-request-bytes \'33554432\' --quota-backend-bytes \'8589934592\'\n\n\n\n\n\n#node1\n\netcd -name perofu1 -debug \\\n-initial-advertise-peer-urls http://0.0.0.0:2380 \\\n-listen-peer-urls http://0.0.0.0:2380 \\\n-listen-client-urls http://0.0.0.0:2379 \\\n-advertise-client-urls http://0.0.0.0:2379 \\\n-initial-cluster-token etcd-cluster-1 \\\n-initial-cluster perofu1=http://0.0.0.0:2380,perofu2=http://0.0.0.0:4380 \\\n-initial-cluster-state new  >> /var/log/kubernetes/test-etcd.log 2>&1 &\n\n#node2\n\netcd -name perofu2 -debug \\\n-initial-advertise-peer-urls http://0.0.0.0:4380 \\\n-listen-peer-urls http://0.0.0.0:4380 \\\n-listen-client-urls http://0.0.0.0:4379 \\\n-advertise-client-urls http://0.0.0.0:4379 \\\n-initial-cluster-token etcd-cluster-1 \\\n-initial-cluster perofu1=http://0.0.0.0:2380,perofu2=http://0.0.0.0:4380 \\\n-initial-cluster-state new  >> /var/log/kubernetes/test-etcd-1.log 2>&1 &\n\n\n● –data-dir 指定节点的数据存储目录，若不指定，则默认是当前目录。这些数据包括节点ID，集群ID，集群初始化配置，Snapshot文件，若未指 定–wal-dir，还会存储WAL文件\n● –wal-dir 指定节点的was文件存储目录，若指定了该参数，wal文件会和其他数据文件分开存储\n● –name 节点名称\n● –initial-advertise-peer-urls 告知集群其他节点的URL，tcp 2380端口用于集群通信\n● –listen-peer-urls 监听URL，用于与其他节点通讯\n● –advertise-client-urls 告知客户端的URL, 也就是服务的URL，tcp 2379端口用于监听客户端请求\n● –initial-cluster-token 集群的ID\n● –initial-cluster 集群中所有节点\n● –initial-cluster-state 集群状态，new为新创建集群，existing为已存在的集群\n \nnohup etcd --name cd0   --data-dir=/data/db/etcd/cd0   --initial-advertise-peer-urls http://0.0.0.0:2380   --listen-peer-urls http://0.0.0.0:2380   --listen-client-urls http://0.0.0.0:2379   --advertise-client-urls http://0.0.0.0:2379  --initial-cluster-token etcd-cluster-1   --initial-cluster cd0=http://0.0.0.0:2380,cd1=http://0.0.0.0:2480,cd2=http://0.0.0.0:2580   --initial-cluster-state new &\nnohup etcd --name cd1   --data-dir=/data/db/etcd/cd1   --initial-advertise-peer-urls http://0.0.0.0:2480   --listen-peer-urls http://0.0.0.0:2480   --listen-client-urls http://0.0.0.0:2479   --advertise-client-urls http://0.0.0.0:2479  --initial-cluster-token etcd-cluster-1   --initial-cluster cd0=http://0.0.0.0:2380,cd1=http://0.0.0.0:2480,cd2=http://0.0.0.0:2580   --initial-cluster-state new &\nnohup etcd --name cd2   --data-dir=/data/db/etcd/cd2   --initial-advertise-peer-urls http://0.0.0.0:2580   --listen-peer-urls http://0.0.0.0:2580   --listen-client-urls http://0.0.0.0:2579   --advertise-client-urls http://0.0.0.0:2579  --initial-cluster-token etcd-cluster-1   --initial-cluster cd0=http://0.0.0.0:2380,cd1=http://0.0.0.0:2480,cd2=http://0.0.0.0:2580   --initial-cluster-state new &\n\n\n\n\n##查看有多少个节点 \n[root@node222 etcd]# etcdctl --write-out=table --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580 member list\n+------------------+---------+------+-----------------------+-------------------------------------------------+------------+\n|        ID        | STATUS  | NAME |      PEER ADDRS       |                  CLIENT ADDRS                   | IS LEARNER |\n+------------------+---------+------+-----------------------+-------------------------------------------------+------------+\n| 98f0c6bf64240842 | started |  cd2 | http://127.0.0.1:2580 | http://127.0.0.1:2579,http://192.168.3.222:2579 |      false |\n| bf9071f4639c75cc | started |  cd0 | http://127.0.0.1:2380 | http://127.0.0.1:2379,http://192.168.3.222:2379 |      false |\n| e3ba87c3b4858ef1 | started |  cd1 | http://127.0.0.1:2480 | http://127.0.0.1:2479,http://192.168.3.222:2479 |      false |\n+------------------+---------+------+-----------------------+-------------------------------------------------+------------+\n\n##删除某节点\netcdctl --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580  member remove bf9071f4639c75cc\n\n###https://www.jianshu.com/p/afc51382cc62 添加某节点后启动节点\n\n##键值对写入### 注意重复写入会有版本的概念  并非覆盖\n[root@node222 etcd]# etcdctl  --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580 put foo \"hello world\"\nOK\n[root@node222 etcd]# etcdctl  --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580 get foo\nfoo\nhello world\n[root@node222 etcd]# etcdctl  --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580 get foo --write-out=\"json\"\n{\"header\":{\"cluster_id\":11360555963653019356,\"member_id\":11020526813496739906,\"revision\":3,\"raft_term\":37},\"kvs\":[{\"key\":\"Zm9v\",\"create_revision\":2,\"mod_revision\":3,\"version\":2,\"value\":\"aGVsbG8gd29ybGQ=\"}],\"count\":1}\n\n##键值对读取## 注意可以更具版本号读取\n[root@node222 etcd]# etcdctl  --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580 get --rev=3 foo\nfoo\nhello world\n[root@node222 etcd]# etcdctl  --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580 get --rev=4 foo\nfoo\nhello world\n[root@node222 etcd]# etcdctl  --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580 get --rev=5 foo\nfoo\nhello 9999999 world\n[root@node222 etcd]# etcdctl  --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580 get --rev=6 foo\n{\"level\":\"warn\",\"ts\":\"2019-10-12T11:40:01.005+0800\",\"caller\":\"clientv3/retry_interceptor.go:61\",\"msg\":\"retrying of unary invoker failed\",\"target\":\"endpoint://client-e1782aa5-33f7-4b74-a9e1-a69c871a1af1/127.0.0.1:2380\",\"attempt\":0,\"error\":\"rpc error: code = OutOfRange desc = etcdserver: mvcc: required revision is a future revision\"}\nError: etcdserver: mvcc: required revision is a future revision\n\n\n\n##监控某个key  多端监控多端都能收到对应value的变化### 做公共配置管理非常适合 \n[root@node222 etcd]# etcdctl  --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580 watch foo \nPUT\nfoo\nhello world 777 \n\n\n###创建租约###  服务发现场景\n[root@node222 ~]# etcdctl lease grant 30 --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580 \nlease 08426dbddd4ed31f granted with TTL(30s)\n\n###维持租约###  每个服务启动时都将自己ip 端口作为租约key  不断向etcd发送心跳包，以此保证服务是否正常 \n[root@node222 ~]# etcdctl lease keep-alive 08426dbddd4ed31f --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580 \nlease 08426dbddd4ed31f keepalived with TTL(30)\nlease 08426dbddd4ed31f keepalived with TTL(30)\nlease 08426dbddd4ed31f keepalived with TTL(30)\n\n###在租约上操作 put kv### \n[root@node222 ~]# etcdctl --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580  put --lease=08426dbddd4ed31f foo 123456\nOK\n\n###获取kv 注意获取不带租约信息，因为租约一旦过期etcd会删除租约上的kv### \n[root@node222 ~]# etcdctl --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580  get foo\nfoo\n123456\n\n\n###分布式锁###\n[root@node222 ~]# etcdctl --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580  lock foo\nfoo/75cc6dbddc38871d   \n注意:有返回值代表拿到了锁  \n\n[root@node222 ~]# etcdctl --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580  lock foo\n 只要上面的终端不退出(如ctrl + C) 本次一直等待，将会拿不到返回值\n\n\n ###选举###\n[root@node222 ~]# etcdctl --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580  elect foo serverone\nfoo/8426dbddd4ed32c\nserverone   \n注意:有返回值代表拿到了 \n\n[root@node222 ~]# etcdctl --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580  elect foo servertwo\n 只要上面的终端不退出(如ctrl + C) 本次一直等待，将会拿不到返回值\n\n\n###集群监控状态检查##\n[root@node222 ~]# etcdctl --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580  endpoint status\n127.0.0.1:2380, bf9071f4639c75cc, 3.5.0-pre, 29 kB, true, false, 37, 50, 50, \n127.0.0.1:2480, e3ba87c3b4858ef1, 3.5.0-pre, 29 kB, false, false, 37, 50, 50, \n127.0.0.1:2580, 98f0c6bf64240842, 3.5.0-pre, 25 kB, false, false, 37, 50, 50, \n\n###集群监控健康检查##\n[root@node222 ~]# etcdctl --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580  endpoint health\n127.0.0.1:2580 is healthy: successfully committed proposal: took = 9.07441ms\n127.0.0.1:2380 is healthy: successfully committed proposal: took = 7.299747ms\n127.0.0.1:2480 is healthy: successfully committed proposal: took = 7.40834ms\n\n###快照##\n[root@node222 ~]# etcdctl --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580 snapshot save my.db\nError: snapshot must be requested to one selected node, not multiple [127.0.0.1:2380 127.0.0.1:2480 127.0.0.1:2580]\n快照必须被请求到一个选中的节点，而不是多个\n\n[root@node222 ~]# etcdctl --endpoints=127.0.0.1:2380 snapshot save my.db\n{\"level\":\"info\",\"ts\":1570857625.6082067,\"caller\":\"snapshot/v3_snapshot.go:109\",\"msg\":\"created temporary db file\",\"path\":\"my.db.part\"}\n{\"level\":\"warn\",\"ts\":\"2019-10-12T13:20:25.608+0800\",\"caller\":\"clientv3/retry_interceptor.go:116\",\"msg\":\"retry stream intercept\"}\n{\"level\":\"info\",\"ts\":1570857625.608486,\"caller\":\"snapshot/v3_snapshot.go:120\",\"msg\":\"fetching snapshot\",\"endpoint\":\"127.0.0.1:2380\"}\n{\"level\":\"info\",\"ts\":1570857625.6244974,\"caller\":\"snapshot/v3_snapshot.go:133\",\"msg\":\"fetched snapshot\",\"endpoint\":\"127.0.0.1:2380\",\"took\":0.016090956}\n{\"level\":\"info\",\"ts\":1570857625.6245813,\"caller\":\"snapshot/v3_snapshot.go:142\",\"msg\":\"saved\",\"path\":\"my.db\"}\nSnapshot saved at my.db\n\n\n[root@node222 ~]# etcdctl --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580 snapshot status my.db\nf964a518, 27, 34, 29 kB\n[root@node222 ~]# etcdctl --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580 snapshot status my.db --write-out=table  (注意--endpoints=填写任意节点都能找到)\n+----------+----------+------------+------------+\n|   HASH   | REVISION | TOTAL KEYS | TOTAL SIZE |\n+----------+----------+------------+------------+\n| f964a518 |       27 |         34 |      29 kB |\n+----------+----------+------------+------------+\n\n\n\nexport ETCDCTL_API=3\nENDPOINTS=localhost:2379\n\netcdctl --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580  role add root\netcdctl --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580 role grant-permission root readwrite foo\netcdctl --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580 role get root\n\netcdctl --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580 user add root\netcdctl --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580 user grant-role root root\netcdctl --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580 user get root\n\netcdctl --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580 auth enable\n# now all client requests go through auth\n\netcdctl --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580 --user=root:123 put foo bar\netcdctl --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580 get foo\netcdctl --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580 --user=root:123 get foo\netcdctl --endpoints=127.0.0.1:2380,127.0.0.1:2480,127.0.0.1:2580 --user=root:123 get foo1\n\n\nnohup etcd --name cd0   --data-dir=/data/db/etcd/cd0   --initial-advertise-peer-urls http://0.0.0.0:2380   --listen-peer-urls http://0.0.0.0:2380   --listen-client-urls http://0.0.0.0:2379   --advertise-client-urls http://0.0.0.0:2379  --initial-cluster-token etcd-cluster-1   --initial-cluster cd0=http://0.0.0.0:2380,cd1=http://0.0.0.0:2480,cd2=http://0.0.0.0:2580   --initial-cluster-state new &\n\nnohup etcd --name cd1   --data-dir=/data/db/etcd/cd1   --initial-advertise-peer-urls http://0.0.0.0:2480   --listen-peer-urls http://0.0.0.0:2480   --listen-client-urls http://0.0.0.0:2479   --advertise-client-urls http://0.0.0.0:2479  --initial-cluster-token etcd-cluster-1   --initial-cluster cd0=http://0.0.0.0:2380,cd1=http://0.0.0.0:2480,cd2=http://0.0.0.0:2580   --initial-cluster-state new &\n\nnohup etcd --name cd2   --data-dir=/data/db/etcd/cd2   --initial-advertise-peer-urls http://0.0.0.0:2580   --listen-peer-urls http://0.0.0.0:2580   --listen-client-urls http://0.0.0.0:2579   --advertise-client-urls http://0.0.0.0:2579  --initial-cluster-token etcd-cluster-1   --initial-cluster cd0=http://0.0.0.0:2380,cd1=http://0.0.0.0:2480,cd2=http://0.0.0.0:2580   --initial-cluster-state new &\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```',2,'admin',0,0,0,0,1,0,'',3,0,0,'2000-01-01 00:00:00',NULL,'2022-04-22 16:38:06'),
	(81,'编码   ascII  gb2312 gbk unicode utf-8','# 编码   ascII  gb2312 gbk unicode utf-8\n\n```\nascII  gb2312 gbk unicode utf-8\n\n1. 最初美国人用 8 个开关来表示各种信息 一共可以2^8次方  256种变化 足够美国人使用 1-127 包括字母数字符号 128-255特殊符号\n2. 中国人用128-255 每两个字节组成一个汉字 称为gb2312 后来不够用扩展用一个大于128的字节和一个0-255的字节组成一个汉字 称为gbk\n3. 后来一个组织统一编码用3-4个字节表示一个字符,称为Unicode\n4. 由于互联网的发展字符要通过网路传输 ，而一个文本用Unicode编码占用空间太大 \n  于是utf-8产生了,它让一个字节可以表示的任然用一个字节,2至3个字节的就用2-3个字节 \n\n```',2,'admin',0,0,0,0,2,0,'',3,0,0,'2000-01-01 00:00:00',NULL,'2022-04-22 16:39:06'),
	(83,'gitlab ci ','# gitlab-ci\n\n## 安装 方式一\n- curl -LJO \"https://gitlab-runner-downloads.s3.amazonaws.com/latest/deb/gitlab-runner_amd64.deb\"\n- dpkg -i gitlab-runner_amd64.deb\n\n\n## 安装 方式二\n- $ sudo curl -L --output /usr/local/bin/gitlab-runner \"https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64\"\n- $ sudo chmod +x /usr/local/bin/gitlab-runner\n- $ sudo useradd --comment \'GitLab Runner\' --create-home gitlab-runner --shell /bin/bash\n- $ # Optional sudo rm /etc/systemd/system/gitlab-runner.service\n- $ sudo gitlab-runner install --user=gitlab-runner --working-directory=/home/gitlab-runner\n\n\n\n\n## 注册\n```\nroot@xxx-dev:~# gitlab-runner register\nERRO[0000] Docker executor: prebuilt image helpers will be loaded from /var/lib/gitlab-runner. \nRunning in system-mode.                            \n                                                   \nPlease enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/):\nhttps://gitlab.stnts.com/\nPlease enter the gitlab-ci token for this runner:\npDkoHyxpxkgc3Cv\nPlease enter the gitlab-ci description for this runner:\n[xxx-dev]: Cocos Creator h5小游戏 及 游戏大厅  \nPlease enter the gitlab-ci tags for this runner (comma separated):\n1.0.0\nRegistering runner... succeeded                     runner=pDkoHyxp\nPlease enter the executor: docker+machine, docker-ssh, ssh, shell, virtualbox, docker-ssh+machine, kubernetes, docker, parallels:\nshell\nRunner registered successfully. Feel free to start it, but if it\'s running already the config should be automatically reloaded! \nroot@xxx-dev:~# ll\n\n```\n\n## 删除无效runner\ngitlab-runner verify --delete --name xxx\n\n\n## 重新加载配置  \ngitlab-runner restart\n\n\n##  注意点 \n- 如果gitlab界面显示灰色不在线  则查看一下进程是否存在 \n-- /usr/bin/gitlab-runner run --working-directory /home/gitlab-runner --config /etc/gitlab-runner/config.toml --service gitlab-runner --user root\n-- 目录是否 存在 mkdir  /home/gitlab-runner\n```\nroot@xxx-dev:/workspace# cat /etc/systemd/system/gitlab-runner.service\n[Unit]\nDescription=GitLab Runner\nConditionFileIsExecutable=/usr/bin/gitlab-runner\n \nAfter=syslog.target network.target \n\n[Service]\nStartLimitInterval=5\nStartLimitBurst=10\nExecStart=/usr/bin/gitlab-runner \"run\" \"--working-directory\" \"/home/gitlab-runner\" \"--config\" \"/etc/gitlab-runner/config.toml\" \"--service\" \"gitlab-runner\" \"--user\" \"root\"\n\n\n\n\n\n\n\nRestart=always\n\nRestartSec=120\nEnvironmentFile=-/etc/sysconfig/gitlab-runner\n\n[Install]\nWantedBy=multi-user.target\n```\n\n\n\n## 注意点:  .gitlab-ci.yml配置 被坑1天  一直提示找不到go命令 要先执行一下 profile\n-   source /etc/profile  ',2,'admin',0,0,0,0,2,0,'',3,0,0,'2000-01-01 00:00:00',NULL,'2022-04-22 16:44:28'),
	(84,'Makefile 文件格式','# Makefile 文件格式\n\n```\nMakefile 公式:\n   \n目标: 依赖文件 \n	命令            ##注意命令的前面是1个table键\n\n\nMakefile 存在系统默认的自动化变量:\n\n$^  表示所有的依赖文件\n$@  代表目标\n$<  代表第一个依赖文件\n\n\nMakefile clean 清理编译过程中中间文件的 \n \n.PHONY: clean   <-- 这句没有也行, 但是最好加上,,目标并不是一个\"目标(target)\", 不像真正的目标那样会生成一个目标文件.\nclean:\n    rm -f *.o\n\n\n	\n	\n	180  50       160 \n	420  150      440 \n	 \n	\n示例：\n	\nCC=gcc\nCFLAGS=-Wall -g -DDEBUG\nLDFLAGS=\nLIBS=\n\nall: 1-1\n\n1-1: 1-1.c\n	$(CC) -o $@ $(LDFLAGS) $^ $(LIBS)\n\nclean:\n	rm -rf *.o\n\n \n \n \n  \n \n\n```',2,'admin',0,0,0,0,3,0,'',3,0,0,'2000-01-01 00:00:00',NULL,'2022-04-22 16:49:04'),
	(85,'rsync 服务器之间文件同步 ','### 服务器之间文件同步  安装部署\n\n```\nA 机器 服务端\n[root@localhost /]# yum -y install rsync\n[root@localhost /]# vi /etc/rsyncd.conf \nuid = root\ngid = root\nuse chroot = no                 //不使用chroot\nmax connections = 4             // 最大连接数为4\nstrict modes =no                //是否检查口令文件的权限\nport = 873                      //默认端口873\nlog file =/var/log/rsyncd.log\npid file = /var/run/rsyncd.pid\nlock file = /var/run/rsync.lock\n\n[www]                   //这里是认证的模块名，在client端需要指定\npath = /data/cluster/web/src/im\nread only = no\nlist = no\nauth users = kfd\nsecrets file = /etc/rsyncd.secrets\nhosts allow = 192.168.137.222       //允许主机 \n\n[root@localhost /]# vi /etc/rsyncd.secrets \nkfd:123456\n\n[root@localhost /]#chmod 600 /etc/rsyncd.secrets  \n[root@localhost /]# chmod 600 /etc/rsyncd.conf \n[root@localhost /]# cmhod -R 777  /data/cluster/web/src/im\n[root@localhost /]#  chmod -R 777  /data/cluster/web/src/im \n[root@localhost /]# /usr/bin/rsync --daemon --config=/etc/rsyncd.conf\n\n\n\nB 机器 客户端\n[root@localhost /]# yum -y install rsync\n[root@localhost src]# vi /etc/rsync.pas \n123456\n[root@localhost src]# cat /etc/xinetd.d/rsync \n# default: off\n# description: The rsync server is a good addition to an ftp server, as it \\\n#       allows crc checksumming etc.\nservice rsync\n{\n        disable = no\n        flags           = IPv6\n        socket_type     = stream\n        wait            = no\n        user            = root\n        server          = /usr/bin/rsync\n        server_args     = --daemon\n        log_on_failure  += USERID\n}\n\n[root@localhost src]# /usr/bin/rsync -vzrtopg --progress --delete kfd@192.168.137.111::www /data/cluster/web/src/im --password-file=/etc/rsync.pas\n\n\n\n\n\n*/1 * * * *  /usr/bin/rsync -vzrtopg --progress --delete kfd@10.24.166.20::www /data/cluster/web/src/im --password-file=/etc/rsync.pas > /dev/null\n```',2,'admin',0,0,0,0,9,0,'',3,0,0,'2000-01-01 00:00:00','2022-04-22 19:55:36','2022-04-22 16:52:13'),
	(86,'svn 服务','# svn 服务  使用及搭建\n\n###  svn 安装教程\n\n``` \n\n第一步： yum install subversion;\n \n第二步：  svnadmin create  /data/cluster/sa/vc\n\n第三步： mkdir /data/cluster/sa/vc/svn\n\n第四步：\nsvnadmin create  /data/cluster/sa/vc/svn/mg \n\nsvnadmin create  /data/cluster/sa/vc/svn/html\n\nsvnadmin create  /data/cluster/sa/vc/svn/yw\n\n \n\n第五步：配置\n[root@iZ28pw7sv4qZ vc]# cat conf/authz \n[groups]\nadmin=king,ocean,hanke,aiden\nmg=chenlin,aiden,xin,yuxiang,xiangcheng,king,chenggang\nyongwo=yongwo,xsk,zyj\nhtml=sam\n\n[bf:/]\n@admin= rw\n\n[mg:/]\n@mg = rw\n\n[mg:/trunk/ywcf]\n@yongwo=rw\n\n[html:/]\n@mg = rw\n@html = rw\n\n \n\n \n\n[root@iZ28pw7sv4qZ vc]# cat conf/passwd \n[users]\nking=123456\nocean=123456\nhanke=123456\naiden=123456\nxiangcheng=123456\nxin=123456\nyuxiang=123456\nchenlin=123456\nyongwo=123456\nsam=123456\nxsk=yw@2015\nzyj=yw@2015\nchenggang=123456\n\n \n\n[root@iZ28pw7sv4qZ vc]# cat conf/svnserve.conf |grep -v \"^#\";\n[general]\nanon-access = none\npassword-db = passwd\nauthz-db = authz\nrealm = /data/cluster/sa/vc/svn\n[sasl]\n\n \n\n \n\n \n\n第六步：启动 \n[root@iZ28pw7sv4qZ vc]#/usr/bin/svnserve --daemon --pid-file=/var/run/svnserve.pid --log-file=//data//log/svnserve.log --config-file=/data/cluster/sa/vc/conf/svnserve.conf -r /data/cluster/sa/vc/svn\n\n \n\n \n\n第七步：同步web目录钩子配置\n[root@iZ28pw7sv4qZ vc]#vi /data/cluster/sa/vc/svn/mg/hooks/post-commit\n#!/bin/sh\nREPOS=\"$1\"\nREV=\"$2\"\n \nexport PATH=\"/usr/local/svn/bin:$PATH\"  #由于代码是apache的进程用户www运行，所以需要设置环境变量\nexport LC_CTYPE=en_US.UTF-8             #防止提交的文件名存在非字母字符\nsvn update /data/cluster/web/mg/ > /dev/null\necho \'111\' >> /data/log/1.txt  #写日志查看是否成功\n\n\n \n\n[root@iZ28pw7sv4qZ vc]# chmod 0777 /data/cluster/sa/vc/svn/mg/hooks/post-commit\n\n第八步：\n\n[root@iZ28pw7sv4qZ vc]#cd  /data/cluster/web/src/mg   \n\nsvn co svn://120.27.104.3/mg\n \n\n\n\n\n\n提交时遇到错误 \n[root@iZ28pw7sv4qZ html]# svn ci -m \"\"\nsvn: Commit failed (details follow):\nsvn: Aborting commit: \'/data/cluster/web/src/html/im\' remains in conflict\n\n解决方案一\n[root@iZ28pw7sv4qZ html]# svn revert  im         扔掉所有你的本地修改  \n[root@iZ28pw7sv4qZ html]# svn resolved im        告诉svn已经解决im目录的冲突\n```\n',2,'admin',0,0,0,0,4,0,'',3,0,0,'2000-01-01 00:00:00','2022-04-22 19:55:06','2022-04-22 16:54:17'),
	(90,'webrtc 语音案例','# webrtc 语音案例\n==============\n\n## 介绍\n- 一个运行在web浏览器上的 webrtc语音实时在线 案例 \n- 地址 https://github.com/poembro/webrtc-audio\n\n## 安装 (linux版本) \n\n#########turnserver 配置方式一############\n```\n[root@xxx log]# wget wget https://github.com/coturn/coturn/archive/4.5.1.1.tar.gz\n[root@xxx log]# tar -zxvf 4.5.1.1.tar.gz\n[root@xxx log]# cd coturn-4.5.1.1/\n[root@xxx log]# ./configure \n[root@xxx log]# make\n[root@xxx log]# make isntall  \n\n[root@xxx log]# vi /etc/turnserver.conf\n[root@xxx log]# cat  /etc/turnserver.conf |grep ^[^#]\nlistening-port=8080\nlistening-ip=172.24.90.65\nexternal-ip=47.111.11.11\nmin-port=49152\nmax-port=65535 \n\nverbose \n\nfingerprint\nuse-auth-secret\nstatic-auth-secret=\"123456\"\nserver-name=webrtc.pyxxxxx.cn\nrealm=webrtc.pyxxxxx.cn\ncert=/etc/turn_server_cert.pem\npkey=/etc/turn_server_pkey.pem\nlog-file=/data/log/turn.log\nsimple-log\n\nno-stun\npidfile=\"/var/run/turnserver.pid\"\nproc-user=turnserver\nproc-group=turnserver\ncli-password=qwerty\n\n```\n###  启动\n```\n[root@xxx log]#  turnserver -v -r 47.111.11.11 -a -o -c /etc/turnserver.conf\n\n\nhttps://www.jianshu.com/p/915eab39476d \nhttps://icetest.info/ 测试\n```\n\n## turnserver 配置方式二(暂时不采用)\n ```\n[root@xxx log]# cat  /etc/turnserver.conf-bak |grep ^[^#]\nlistening-port=8080 \nlistening-ip=172.24.90.65\nexternal-ip=47.111.11.11\nmin-port=49152\nmax-port=65535\n\nverbose\n\nfingerprint\nlt-cred-mech\nserver-name=webrtc.pyxxxxx.cn\nuser=test:123456\nrealm=webrtc.pyxxxxx.cn\ncert=/etc/turn_server_cert.pem\npkey=/etc/turn_server_pkey.pem\nlog-file=/data/log/turn.log\nsimple-log\n			\nno-stun\npidfile=\"/var/run/turnserver.pid\"\nproc-user=turnserver\nproc-group=turnserver\ncli-password=qwerty\n\n```\n\n## 服务端golang接口逻辑\n```\n[root@xxx log]#git clone git@github.com:bmpi-dev/kraken.git\n[root@xxx log]#cd kraken && go build \n[root@xxx log]#nohup /data/web/webrtc/kraken -c ./engine.toml -s engine  &\n[root@xxx webrtc]# cat engine.toml \n[engine]\n# the network interface to bind\ninterface = \"eth0\"\n# the IP address to bind, empty allows the engine to get it from interface\naddress = \"172.24.90.65\"\nlog-level = 10\n# the UDP port range, leave them to 0 for default strategy\nport-min = 0\nport-max = 0\n\n[turn]\nhost = \"turn:47.111.11.11:8080\"\n# must be identical to coturn static auth secret\nsecret = \"123456\"\n\n[rpc]\nport = 7000\n```\n\n## 前端\n``` bash\n#nodejs v16+\n$ cd /webrtc-audio/demo\n# install dependencies\n$ yarn install\n\n# serve with hot reload at localhost:3000\n$ yarn dev\n\n# build for production and launch server\n$ yarn build\n$ yarn start\n\n# generate static project\n$ yarn generate\n```\n\n\n \n## nginx\n```\nupstream kfdchat {\n  server 172.24.90.65:7000 weight=100 max_fails=5 fail_timeout=5;\n}\n\n\nserver {\n    listen 443 ssl; \n    server_name webrtc.pyxxxxx.cn; \n    ssl_certificate   \"/usr/local/openresty/nginx/conf/ssl/webrtc.pyxxxxx.cn_chain.crt\";\n    ssl_certificate_key   \"/usr/local/openresty/nginx/conf/ssl/webrtc.pyxxxxx.cn_key.key\";\n    ssl_session_timeout 5m;\n    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n    ssl_prefer_server_ciphers on;\n    ssl_verify_client off;\n    autoindex off;\n    server_tokens off;  \n\n    server_name -;\n    index index.php index.html index.htm;\n\n    # 项目本身的静态文件\n    location / {\n         proxy_pass http://kfdchat;\n    }\n\n}\n```',2,'admin',0,0,0,0,11,0,'',3,1,0,'2000-01-01 00:00:00','2022-04-22 17:51:09','2022-04-22 17:13:27'),
	(91,'联通营销客服 到底是什么样的存在？','\n### 起因是这样的, 2022 年 01 月 29 日 17 点 23 分(春节前 3 天),手机接到 联通营销客服电话(027)59557285 对话内容如下:\n\n```\n营销客服: \"您好!请问您是 xxx 机主吗?\"\n我: \"你是谁?\"\n营销客服: \"我是联通客服代表; 联通现在针对春节期间,做出的人人都可享有的优惠流量活动。不影响您当前套餐,不开通任何业务服务,下月自动生效。 \"\n我: \"那既然所有用户都是,又自动生效。 你是过来通知我的吗？\"\n营销客服:\"不是的~~~~。 \" (支支吾吾说不清楚)\n我: \"那好吧\" (挂断电话)\n\n结果:次月发现她还是给我开通了\"39 元 5G 版超级会员(黄金版)-次月生效套餐\" (吐血~过年农村老家又没有 5G 信号)\n```\n\n##  开始拨打维权电话\n```\n第一天\n\n致电 10010 人工服务对话如下：\n\n我：\"我想问下，我现在开通了什么套餐服务吗？\"\n\n客服： \"您有个 \'39 元 5G 版超级会员(黄金版)\' 套餐 \"\n\n我: \"为什么会多这个套餐\"\n\n客服：\"2022 年 01 月 29 日 17 点 23 分 我们的营销客服人员给您打过电话 是您同意了才开通的\"\n\n我: \"我没同意啊， 是你们这边通知我 说所有人都有 这个春节流量优惠； 。。。。。 然后 那事已至此，我现在怎么举报，\"\n\n\n客服：\"我们稍后会给您电话，请保持手机通信畅通\"\n\n\n---------------------------------------------------------------------\n\n第二天 也就是今天，10010 给我来电 内容如下：\n\n10010 客服： \"接到您的投诉，现在 各自承担一 半套餐费用，您是否愿意\"\n\n我: \"你们在欺骗用户，我为什么要承担\"\n\n10010 客服： \"那我们全额返还呢，您看可以么\"\n\n我: \"那也行\"\n\n10010 客服： \"我现在帮您向上级申请。\"\n\n我: \"申请 还要你们同意，我又没犯错 为什么要申请。\" (挂断电话，后续没有再继续接听 10010 电话)\n\n```\n\n##  最后结果\n\n```\n  一周后，全额返还退回至话费\n```\n\n',2,'admin',0,0,2,0,10,2,'admin',2,1,0,'2022-04-22 18:47:41','2022-04-22 19:52:21','2022-04-22 18:45:47'),
	(93,'一个运行在OpenResty上的客服聊天软件。','# OpenResty IM  \n- 一个运行在[OpenResty](http://openresty.org)上的客服聊天软件。\n- 地址 https://github.com/poembro/openresty-im\n\n---\n\n## 特点\n- 简洁  \n- 高性能\n- 代码完全采用ngx-lua + redis实现\n- 支持心跳包,已读/未读数,历史消息同步,断线重连等\n- 采用redis发布、订阅做推送\n- 采用TLV协议格式，保持与B站开源项目[goim](https://github.com/Terry-Mao/goim)协议一致\n- c10K以内的并发连接完全够用\n---\n\n## 描述\n- 适用于中小型项目，新项目直接上goim推送，维护成本太高，短时间内很难驾驭，于是折中一下写了这个demo。既能应对当前开发工作量,也确保了后期无缝切换后端推送服务 \n\n---\n\n## 案例\n\n   [体验demo](https://kefu.sgsbbs.cn/find.html)\n\n---\n\n\n## 项目目录简介\n```\napi:          http api服务代码 (负责组装/验证参数 跳转到聊天页面的接口,接收新消息的接口)\ncomet:        推送服务代码 (负责下发消息, 客户端通过http协议，将新消息POST到api服务,写入redis,再由推送服务读取redis 下发)\ndist:         前端html代码\nlibs:         自定义的共有代码\nlor:          http服务框架代码\nresty:        第三方基础库代码(如 snowflake 雪花算法生成唯一id)\nconfig:       配置\n``` \n\n---\n\n### 设计方案\n**所有的聊天回话都是向某一个room_id中写消息**：\n- 新成员进入聊天窗口，都必先有个唯一mid标识,两个成员直接相互聊天，本质上就是向两个mid拼接后的字符串(room_id)写消息；如果有多人群聊即多对多，需额外处理，并不影响该设计\n\n**推送消息时采用读扩散**：\n- 即所有消息只写1次. 所有人发送的消息时都有个room_id，服务端将消息入库到对应room_id中，并且客户端每读1条消息将会上报该消息的偏移位置\n\n**redis采用5种不同类型的key**:\n- hset(mid, key, userJson)    注:用户表  mid即唯一用户id;  key即:设备标识; userJson即用户详细 如头像 昵称等\n- set(key, server_ip)         注:在线标识  心跳包维持过期时间\n- hset(mid_seq, room_id, snowflake_id) 注:用户读取的偏移位置\n- zadd(userlist:shop_id,time(),mid) 注:1个商户下有多个新成员,用于商户管理属于自己的用户\n- zadd(room_id,snowflake_id,msg)  注:消息表\n- sadd  \"shoplist:\" 8000       注:汇总所有商户 方便统计运营\n- lpush shop_id mid            注:商户管理界面临时会话列表页面 只关心最新的消息.\n\n---\n\n## 安装\n``` \n1. 安装redis 并启动\n2. 修改 config.lua 配置文件 \n\n[root@iZ~]#wget https://openresty.org/download/openresty-1.11.2.3.tar.gz\n[root@iZ~]#tar xvf openresty-1.11.2.3.tar.gz\n[root@iZ~]#cd openresty-1.11.2.3\n./configure --with-luajit && make && make install\n[root@iZ~]#cd /data/web\n[root@iZ~]#git clone git@github.com:poembro/openresty-im.git \n[root@iZ~]#/usr/local/openresty/sbin/nginx -c /data/web/nginx.conf\n\n\n项目对接：\n客服人员的浏览器打开\nhttps://kefu.sgsbbs.cn/info.html?shop_id=8000\n\n前端网页中相应位置按钮连接改为：\nhttps://kefu.sgsbbs.cn/open/im?shop_id=8000\n\n注： 8000表示商户号,如果有多个商户直接递增如:8001, 前端网页连接 同样改为8001\n```\n\n\n---\n\n## 协议格式  (同goim)\n#### 二进制，请求和返回协议一致 \n| 参数名     | 必选  | 类型 | 说明       |\n| :-----     | :---  | :--- | :---       |\n| package length        | true  | int32 bigendian | 包长度 |\n| header Length         | true  | int16 bigendian    | 包头长度 |\n| ver        | true  | int16 bigendian    | 协议版本 |\n| operation          | true | int32 bigendian | 协议指令 |\n| seq         | true | int32 bigendian | 序列号 |\n| body         | false | binary | $(package lenth) - $(header length) |\n\n\n#### 协议指令\n| 指令     | 说明  | \n| :-----     | :---  |\n| 2 | 客户端请求心跳 |\n| 3 | 服务端心跳答复 |\n| 5 | 下行消息 |\n| 7 | auth认证 |\n| 8 | auth认证返回 |\n| 14 | 同步历史消息 |\n| 15 | 同步历史消息返回 |\n| 16 | 消息ack |\n| 17 | 消息ack返回 |\n---\n\n\n## 捐赠\n#### 比特币(BTC): 38hoh9Hni28sHF8fM9CqbPzGmfaPw1ABxq\n\n\n---\n\n## 感谢\n#### 感谢openresty的开源 感谢goim的开源\n \n \n',10,'poembro',0,0,0,0,7,0,'',3,0,0,'2000-01-01 00:00:00','2022-04-23 16:42:29','2022-04-23 16:22:39'),
	(94,'Orange 一个基于  OpenResty  的API网关 (将nginx.conf配置可视化)','# Orange\n\n [![Build Status](https://travis-ci.org/orlabs/orange.svg?branch=master)](https://travis-ci.org/orlabs/orange) [![license](https://img.shields.io/github/license/orlabs/orange.svg)](https://github.com/orlabs/orange/blob/master/LICENSE)\n\n\n\n`Orange` 是一个基于 `OpenResty` 的API网关。除 `Nginx` 的基本功能外，它还可用于`API监控`、`访问控制(鉴权、WAF)`、`流量筛选`、`访问限速`、`AB测试`、`静/动态分流` 等。它有以下特性：\n\n- 提供了一套默认的 `Dashboard` 用于动态管理各种功能和配置。\n- 提供了API接口用于实现第三方服务(如`个性化运维需求`、`第三方Dashboard`等)。\n- 可根据规范编写自定义插件扩展 `Orange` 功能。\n\n\n## 安装 & 使用\n\n### 生产环境安装（不支持 macOS）\n\n#### 1) 安装依赖项\n\n我们推荐使用 `luarocks` 来安装 `Orange`，以减少由不同操作系统发行版本中的依赖项扩展引起的问题。\n\n在不同的操作系统上安装 `Orange` 所必需的系统依赖（`openresty`、`resty-cli`、`luarocks`等），请参见：[依赖安装文档](docs/install-dependencies.md)。\n\n#### 2) 安装 Lor Framework\n\n查看`Lor Framework`[官方文档](https://github.com/sumory/lor)或执行以下命令。\n\n```bash\ngit clone https://github.com/sumory/lor.git\ncd lor\nsudo make install\n```\n\n#### 3) 安装 Orange\n\n```bash\ncurl -Lo install.sh https://raw.githubusercontent.com/orlabs/orange/master/install/install-orange.sh\nsudo sh install.sh\n```\n\n安装过程结束后，输出消息 `orange 0.8-1 is now installed in /usr/local/orange/deps (license: MIT)` 即说明安装成功。\n\n#### 4) 导入 MySQL\n\n要求：`MySQL`版本 5.5+\n\n - 登录到 `MySQL` 客户端，创建一个 `orange` 数据库。\n \n - 导入数据表（`/usr/local/orange/conf/orange-v0.8.1.sql`）。\n \n - 修改`Orange`配位置文件中（`/usr/local/orange/conf/orange.conf`）`MySQL`相关配置。\n\n#### 5) 启动 Orange\n\n```bash\nsudo orange start\n```\n\n`Orange` 启动成功后，`Dashboard` 和 `API server` 也随之启动：\n\n - 通过 `http://localhost:9999` 访问 `Dashboard`。\n - 通过 `http://localhost:7777` 访问 `API Server`。\n\n至此，`Orange`已全部安装并配置完毕，请尽情享受。\n\n### 开发环境安装（不支持 macOS）\n\n#### 1) 依赖项和Lor\n\n请使用 [生产环境安装](#生产环境安装不支持-macos) 方式中的 [安装依赖项](#1-安装依赖项) 和 [安装 Lor Framework](#2-安装-Lor-Framework) 方法进行安装。\n\n#### 2) 安装 Orange\n\n```bash\ngit clone https://github.com/orlabs/orange.git\ncd orange\nsudo make dev\n```\n\n安装过程结束后，输出消息 `Stopping after installing dependencies for orange-master 1.0-0` 即说明安装成功。\n\n#### 3) 导入 MySQL\n\n请使用 [生产环境安装](#生产环境安装不支持-macos) 方式中的 [导入 MySQL](#4-导入-MySQL) 方法进行导入。\n\n注意：在开发模式下安装 `Orange`。\n\n- `MySQL数据表` 文件和 `Orange配置` 文件位于当前项目的 `conf`文件夹中。\n\n- 请导入 `master` 分支SQL文件（`/usr/local/orange/conf/orange-master.sql`）。\n\n#### 4) 启动 Orange\n\n```bash\nsudo ./bin/orange start\n```\n\n成功启动 `Orange` 后的访问方式，请参考：[生产环境安装](#生产环境安装不支持-macos) 方式中的 [启动 Orange](#5-启动-Orange)。\n\n### 使用\n\n#### 命令行管理工具\n\n通过命令行工具`orange`来管理， 执行`orange help`查看有哪些命令可以使用：\n\n```\nUsage: orange COMMAND [OPTIONS]\n\nThe commands are:\n\nstart   Start the Orange Gateway\nstop    Stop current Orange\nreload  Reload the config of Orange\nrestart Restart Orange\nstore   Init/Update/Backup Orange store\nversion Show the version of Orange\nhelp    Show help tips\n```\n\n## 文档\n\n- 项目文档: [官网](http://orange.sumory.com/docs)\n- API文档: [开放API](./docs/api/README.md)\n\n\n## Docker\n\n[https://store.docker.com/community/images/syhily/orange](https://store.docker.com/community/images/syhily/orange) 由[@syhily](https://github.com/syhily)维护.\n\n## 贡献者\n\n- [@syhily](https://github.com/syhily)\n- [@lhmwzy](https://github.com/lhmwzy)\n- [@spacewander](https://github.com/spacewander)\n- [@noname007](https://github.com/noname007)\n- [@itchenyi](https://github.com/itchenyi)\n- [@Near-Zhang](https://github.com/Near-Zhang)\n- [@khlipeng](https://github.com/khlipeng)\n- [@wujunze](https://github.com/wujunze)\n- [@shuaijinchao](https://github.com/shuaijinchao)\n- [@EasonFeng5870](https://github.com/EasonFeng5870)\n- [@zhjwpku](https://github.com/zhjwpku)\n\n\n\n## See also\n\n`Orange`的插件设计参考自[Kong](https://github.com/Mashape/kong).\n\n## License\n\n[MIT](./LICENSE) License\n',10,'poembro',0,0,0,0,5,0,'',3,0,0,'2000-01-01 00:00:00','2022-04-23 16:55:44','2022-04-23 16:54:08'),
	(95,'Lor  一个运行在OpenResty上的基于Lua编写的Web框架.','# Lor\n\n[![https://travis-ci.org/sumory/lor.svg?branch=master](https://travis-ci.org/sumory/lor.svg?branch=master)](https://travis-ci.org/sumory/lor)  [![GitHub release](https://img.shields.io/github/release/sumory/lor.svg)](https://github.com/sumory/lor/releases/latest) [![license](https://img.shields.io/github/license/sumory/lor.svg)](https://github.com/sumory/lor/blob/master/LICENSE)\n\n\n**Lor**是一个运行在[OpenResty](http://openresty.org)上的基于Lua编写的Web框架.\n\n- 路由采用[Sinatra](http://www.sinatrarb.com/)风格，结构清晰，易于编码和维护.\n- API借鉴了[Express](http://expressjs.com)的思路和设计，Node.js跨界开发者可以很快上手.\n- 支持多种路由，路由可分组，路由匹配支持正则模式.\n- 支持middleware机制，可在任意路由上挂载中间件.\n- 可作为HTTP API Server，也可用于构建传统的Web应用.\n\n\n### 文档\n\n[http://lor.sumory.com](http://lor.sumory.com)\n\n#### 示例项目\n\n- 简单示例项目[lor-example](https://github.com/lorlabs/lor-example)\n- 全站示例项目[openresty-china](https://github.com/sumory/openresty-china)\n\n\n### 快速开始\n\n**特别注意:** 在使用lor之前请首先确保OpenResty已安装，并将`nginx`/`resty`命令配置到环境变量中。即在命令行直接输入`nginx -v`、`resty -v`能正确执行。\n\n一个简单示例(更复杂的示例或项目模板请使用`lord`命令生成)：\n\n```lua\nlocal lor = require(\"lor.index\")\nlocal app = lor()\n\napp:get(\"/\", function(req, res, next)\n    res:send(\"hello world!\")\nend)\n\n-- 路由示例: 匹配/query/123?foo=bar\napp:get(\"/query/:id\", function(req, res, next)\n    local foo = req.query.foo\n    local path_id = req.params.id\n    res:json({\n        foo = foo,\n        id = path_id\n    })\nend)\n\n-- 错误处理插件，可根据需要定义多个\napp:erroruse(function(err, req, res, next)\n    -- err是错误对象\n    ngx.log(ngx.ERR, err)\n    if req:is_found() ~= true then\n        return res:status(404):send(\"sorry, not found.\")\n    end\n    res:status(500):send(\"server error\")\nend)\n\napp:run()\n```\n\n### 安装\n\n\n#### 1）使用脚本安装(推荐)\n\n使用Makefile安装lor框架:\n\n```shell\ngit clone https://github.com/sumory/lor\ncd lor\nmake install\n```\n\n默认`lor`的运行时lua文件会被安装到`/usr/local/lor`下， 命令行工具`lord`被安装在`/usr/local/bin`下。\n\n如果希望自定义安装目录， 可参考如下命令自定义路径：\n\n```shell\nmake install LOR_HOME=/path/to/lor LORD_BIN=/path/to/lord\n```\n\n执行**默认安装**后, lor的命令行工具`lord`就被安装在了`/usr/local/bin`下, 通过`which lord`查看:\n\n```\n$ which lord\n/usr/local/bin/lord\n```\n\n`lor`的运行时包安装在了指定目录下, 可通过`lord path`命令查看。\n\n\n#### 2）使用opm安装\n\n`opm`是OpenResty即将推出的官方包管理器，从v0.2.2开始lor支持通过opm安装：\n\n```\nopm install sumory/lor\n```\n\n注意： 目前opm不支持安装命令行工具，所以此种方式安装后不能使用`lord`命令。\n\n\n#### 3）使用homebrew安装\n\n除使用以上方式安装外, Mac用户还可使用homebrew来安装lor, 该方式由[@syhily](https://github.com/syhily)提供， 更详尽的使用方法请参见[这里](https://github.com/syhily/homebrew-lor)。\n\n```\n$ brew tap syhily/lor\n$ brew install lor\n```\n\n至此， `lor`框架已经安装完毕，接下来使用`lord`命令行工具快速开始一个项目骨架.\n\n\n### 使用\n\n```\n$ lord -h\nlor ${version}, a Lua web framework based on OpenResty.\n\nUsage: lord COMMAND [OPTIONS]\n\nCommands:\n new [name]             Create a new application\n start                  Starts the server\n stop                   Stops the server\n restart                Restart the server\n version                Show version of lor\n help                   Show help tips\n```\n\n执行`lord new lor_demo`，则会生成一个名为lor_demo的示例项目，然后执行：\n\n```\ncd lor_demo\nlord start\n```\n\n之后访问[http://localhost:8888/](http://localhost:8888/)， 即可。\n\n更多使用方法，请参考[use cases](./spec/cases)测试用例。\n\n### Homebrew\n\n[https://github.com/syhily/homebrew-lor](https://github.com/syhily/homebrew-lor)由[@syhily](https://github.com/syhily)维护。\n\n### 贡献者\n\n- [@ms2008](https://github.com/ms2008)\n- [@wanghaisheng](https://github.com/wanghaisheng)\n- [@lihuibin](https://github.com/lihuibin)\n- [@syhily](https://github.com/syhily)\n- [@vinsonzou](https://github.com/vinsonzou)\n- [@lhmwzy](https://github.com/lhmwzy)\n- [@hanxi](https://github.com/hanxi)\n- [@诗兄](https://github.com/269724033)\n- [@hetz](https://github.com/hetz)\n- [@XadillaX](https://github.com/XadillaX)\n\n### 讨论交流\n\n有一个QQ群用于在线讨论: 522410959\n\n### License\n\n[MIT](./LICENSE)\n',10,'poembro',0,0,0,0,4,0,'',3,0,0,'2000-01-01 00:00:00','2022-04-23 16:58:44','2022-04-23 16:57:26'),
	(96,'一个运行在 golang 上的实时通信软件。','# golang-im  \n一个运行在[golang](#)上的实时通信软件。\n\n---\n\n## 特点\n- 简洁 \n- 高性能\n- 支持心跳来维持在线\n- 采用 redis 发布订阅做广播推送 (目前demo代码为了阅读简洁暂采用redis，生产环境可更换为 kafka 等)\n- 采用 TLV 协议格式，保持与[goim](https://github.com/Terry-Mao/goim)一致\n- 采用框架设计参考[gim](https://github.com/alberliu/gim),代码观赏性极好....\n- 采用 etcd 作为服务发现,grpc客户端负载均衡 实现分布式高可用\n\n\n---\n\n## 描述\n- 在学习goim 与 gim 等项目代码后，做的二者结合，用最精简的方式达到练手实践效果。 \n\n\n---\n\n### 设计方案\n**所有的聊天会话都是向某一个room_id中写消息**：\n- 新成员进入聊天窗口，都必先有个唯一device_id设备标识,两个成员直接相互聊天，本质上就是向两个device_id拼接后的字符串(room_id)写消息；如果有多人群聊即多对多，需额外处理，并不影响该设计\n\n\n**golang负责接受并管理连接**：\n- connect 接入层 如  建立连接后 要多一次订阅房间操作,  将以房间号为key  Room结构为值,存放至全局sync.Map ; 所有连接句柄根据房间号,放入对应Room结构的Conns字段(链表)内  有消息过来 根据房间号 遍历链表的句柄 达到推送效果\n- logic   逻辑处理层，如 在线状态存入redis，房间成员信息 ，已读 未读标识。\n\n\n---\n\n## 项目目录简介\n``` \ncmd                        golang 服务启动入口\n    |___connect            接入层 提供对外长连接端口 如 websocket tcp ，提供对内grpc服务端口\n    |___logic              逻辑处理层 提供对内grpc服务端口 \nconfig                     配置 开发环境 本地环境 生产环境\ndist                       静态文件 提供一套完整的 用户端聊天界面 与 客服人员回答界面\n    |___ admin           客服人员聊天静态页面  (一个客服可以跟多个用户聊天)\n    |___ upload          聊天的图片，上传目录\n    |___ im.html         用户端网页咨询窗口的静态页面\ninternal             \n    |___connect             长连接协议处理 ,mq 订阅推送处理)\n    |___logic               内部鉴权,消息逻辑 处理\n       |___ api            grpc 服务方法\n       |___ cache          消息缓存\n       |___ model          用户模型\n       |___ service        服务层为grpc 提供服务逻辑处理\npkg \n    |___ db                外部数据源\n    |___ gerrors           grpc 错误处理\n    |___ gn                epoll tcp服务框架 注:这里解释下,由于改了协议所以没有直接引用 [gn](https://github.com/alberliu/gn)\n    |___ grpclib           采用etcd 做grpc 服务注册、服务发现\n    |___ interceptor       grpc 服务拦截 \n    |___ logger            采用zap 做日志库\n    |___ pb                proto 生成后的文件\n    |___ proto             proto定义grpc 方法和消息结构\n    |___ protocol          TLV消息头 同 [goim](https://github.com/Terry-Mao/goim)  \n    |___ rpc               构建grpc客户端 及 处理服务发现节点\n    |___ urlwhitelist      grpc 服务白名单，如有grpc服务方法需要授权访问 防止外部人员向任意房间发消息\n    |___ util              工具\n \nrun.sh                     普通方式构建 并且 运行 \nDockerfile                 用来构建docker镜像\ndocker.run.build.sh        用来构建为可执行文件，方便拷贝到docker镜像里面去\ndocker-start.sh            docker启动时脚本   \ntcp_client_testing.go      TCP客户端测试脚本  go run tcp_client_testing.go  222 1 192.168.83.165:6923 \n``` \n\n---\n\n## 安装\n``` \n1. 安装docker redis  省略\n2. 启动etcd \ndocker run --name etcd1 -d -p 2379:2379 -p 2380:2380 -v /Users/luoyuxiang/.laradock/data/etcd:/var/etcd -v /etc/localtime:/etc/localtime registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:3.2.24 etcd --name etcd-s1 --auto-compaction-retention=1 --data-dir=/var/etcd/etcd-data  --listen-client-urls http://0.0.0.0:2379  --listen-peer-urls http://0.0.0.0:2380  --initial-advertise-peer-urls http://192.168.83.165:2380  --advertise-client-urls http://192.168.83.165:2379,http://192.168.83.165:2380 -initial-cluster-token etcd-cluster  -initial-cluster \"etcd-s1=http://192.168.83.165:2380,etcd-s2=http://192.168.83.165:2480,etcd-s3=http://192.168.83.165:2580\" -initial-cluster-state new\n\ndocker run --name etcd2  -d -p 2479:2379 -p 2480:2380 -v /Users/luoyuxiang/.laradock/data/etcd2:/var/etcd -v /etc/localtime:/etc/localtime  registry.cn-hangzhou.aliyuncs.com/google_containers/etcd:3.2.24 etcd --name etcd-s2 --auto-compaction-retention=1 --data-dir=/var/etcd/etcd-data  --listen-client-urls http://0.0.0.0:2479  --listen-peer-urls http://0.0.0.0:2480  --initial-advertise-peer-urls http://192.168.83.165:2480  --advertise-client-urls http://192.168.83.165:2479,http://192.168.83.165:2480 -initial-cluster-token etcd-cluster  -initial-cluster \"etcd-s1=http://192.168.83.165:2380,etcd-s2=http://192.168.83.165:2480,etcd-s3=http://192.168.83.165:2580\" -initial-cluster-state new\n\n\n########进入镜像 查看集群状态########\n/ # etcdctl --endpoints=http://192.168.83.165:2379,http://192.168.83.165:2479 member list \ndf339c03e281023: name=etcd-s1 peerURLs=http://192.168.83.165:2380 clientURLs=http://192.168.83.165:2379,http://192.168.83.165:2380 isLeader=true\n4087e512fb03a648: name=etcd-s3 peerURLs=http://192.168.83.165:2580 clientURLs= isLeader=false\n68cbc22003188bb9: name=etcd-s2 peerURLs=http://192.168.83.165:2480 clientURLs=http://192.168.83.165:2479,http://192.168.83.165:2480 isLeader=false\n\n\n########待golang-im节点启动后,执行key前缀匹配,查看etcd中已经存在的节点信息######\n# export ETCDCTL_API=3; etcdctl-3.2.24 --endpoints=http://192.168.83.165:2379,http://192.168.83.165:2479 --write-out=\"simple\"  get g --prefix --keys-only\ngoim:///connectint_grpc_service/192.168.83.165:50000\ngoim:///connectint_grpc_service/192.168.83.165:50002\ngoim:///logicint_grpc_service/192.168.83.165:50100\ngoim:///logicint_grpc_service/192.168.83.165:50102\n\n\n\n3. 安装golang-im 服务\n[root@iZ~]#cd /data/web\n[root@iZ~]#git clone git@github.com:poembro/golang-im.git \n[root@iZ~]#cd /data/web/golang-im\n[root@iZ~]#sh run.sh\n\n4.运行测试网页  \n 4.1 浏览器打开 http://192.168.83.165:8090/admin/login.html\n 4.2 注册 输入手机号 密码 --> 登录  输入手机号 密码\n 4.3 点击 底部导航 ”发现“页面  --> 点击浮动头像  即:表示 打开用户端咨询窗口并发送1条消息、\n 4.4 点击 底部导航 ”消息“ 页面  --> 可以看到 用户列表  即:表示 当前所有找我咨询的用户  --> 点击对应用户头像 即:回复咨询页面 \n\n\n\n5. 多节点集群运行\n- golang 编译构建可执行程序\n[root@iZ~]#sh ./docker.run.build.sh\n\n- 将可执行程序拷贝到 docker 镜像\n[root@iZ~]#docker image build -t golang-im:1.0.18 .\n\n- 用构建好的镜像 启动实例\n第一台机器192.168.83.165,启动第一个实例\n[root@iZ~]#docker run --name golang-im01 -d -p 50000:50000 -p 50100:50100 -p 7923:7923 -p 6923:6923 -p 8090:8090 --env APP_ENV=local --env GRPC_LOGIC_ADDR=192.168.83.165:50100 --env GRPC_CONNECT_ADDR=192.168.83.165:50000 --rm golang-im:1.0.18\n\n第一台机器192.168.83.165,启动第二个实例\n[root@iZ~]#docker run --name golang-im02 -d -p 50002:50000 -p 50102:50100 -p 7924:7923 -p 6923:6923 -p 8090:8090 --env APP_ENV=local --env GRPC_LOGIC_ADDR=192.168.83.165:50102 --env GRPC_CONNECT_ADDR=192.168.83.165:50002 --rm golang-im:1.0.18\n\n第一台机器192.168.83.165,启动第三个实例\n[root@iZ~]#docker run  --name golang-im03 -d -p 50003:50000 -p 50103:50100 -p 7925:7923 --env APP_ENV=local --env GRPC_LOGIC_ADDR=192.168.83.165:50103 --env GRPC_CONNECT_ADDR=192.168.83.165:50003 --rm golang-im:1.0.18\n\n第二台机器192.168.82.220,启动第四个实例 (局域网其他机器 互通)\n[root@iZ~]#docker run  --name golang-im04 -d -p 50000:50000 -p 50100:50100 -p 7923:7923 --env APP_ENV=local --env GRPC_LOGIC_ADDR=192.168.82.220:50100 --env GRPC_CONNECT_ADDR=192.168.82.220:50000 --rm golang-im:1.0.18\n\n\n``` \n\n\n\n\n\n## 协议格式  \n#### 二进制，请求和返回协议一致 \n| 参数名     | 必选  | 类型 | 说明       |\n| :-----     | :---  | :--- | :---       |\n| package length        | true  | int32 bigendian | 包长度 |\n| header Length         | true  | int16 bigendian    | 包头长度 |\n| ver        | true  | int16 bigendian    | 协议版本 |\n| operation          | true | int32 bigendian | 协议指令 |\n| seq         | true | int32 bigendian | 序列号 |\n| body         | false | binary | $(package lenth) - $(header length) |\n\n\n#### 协议指令\n| 指令     | 说明  | \n| :-----     | :---  |\n| 2 | 客户端请求心跳 |\n| 3 | 服务端心跳答复 |\n| 5 | 下行消息 |\n| 7 | auth认证 |\n| 8 | auth认证返回 |\n\n\n---\n \n## 感谢\n\n#### 感谢 gim, goim 等开源项目,有冒犯到原作者的地方请及时指正',10,'poembro',0,0,0,0,1,0,'',3,0,0,'2000-01-01 00:00:00','2022-04-23 16:58:31','2022-04-23 16:58:31'),
	(97,'一个运行在 phaser 引擎上的网页游戏[连环夺宝]。','# 连环夺宝   lhdb\n一个运行在[phaser](<http://phaser.io/>)上的网页游戏[连环夺宝]。\n\n地址 https://github.com/poembro/phaser-lhdb\n\n---\n \n\n## 描述\n- 在学习 phaser 项目后，做的一个完整的 单机游戏，用最精简的代码，达到练手实践效果。 (后续稍加修改可以实现,泡泡龙 消消乐 类型))\n\n---\n\n## 项目目录简介\n``` \nassets                        静态资源 \nbuild                         webpack构建后的文件目录\n \nsrc             \n    |___game                  \n       |___ initModel.js      初始化模块 提前加载当前项目所需的静态资源\n       |___ logicModel.js     游戏逻辑模块\n       \n    |___scenes                游戏场景\n       |___ endScene.js       结束页面\n       |___ mainScene.js      主游戏页面\n       |___ preloadScene      进入游戏前预先加载页面\n    index.js                  入口\n     \n``` \n\n---\n \n## 安装\n``` \n1. 安装node  yarn\n2. yarn add html-webpack-plugin@3.2.0\n3. yarn run start\n \n注: 开发环境下 用根目录下的index.html 作为本地测试页面，其中页面中,根目录下看不到project.bundle.js 但还是引入了，不会报错。  热更新插件会默认生成，能引用到.\n\n\n```\n\n## 素材图\n- 来自 opengameart.org ',10,'poembro',0,0,0,0,4,0,'',3,0,0,'2000-01-01 00:00:00','2022-04-23 17:01:29','2022-04-23 17:00:54');

/*!40000 ALTER TABLE `topic` ENABLE KEYS */;
UNLOCK TABLES;


# Dump of table user
# ------------------------------------------------------------

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `username` varchar(50) NOT NULL DEFAULT '',
  `password` varchar(255) NOT NULL DEFAULT '',
  `avatar` varchar(500) NOT NULL DEFAULT '' COMMENT '头像',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '注册时间',
  `city` varchar(11) NOT NULL DEFAULT '',
  `website` varchar(255) NOT NULL DEFAULT '',
  `company` varchar(100) NOT NULL DEFAULT '',
  `sign` varchar(255) NOT NULL DEFAULT '',
  `github` varchar(30) NOT NULL DEFAULT '',
  `email` varchar(200) NOT NULL DEFAULT '',
  `email_public` int(11) NOT NULL DEFAULT '0' COMMENT '1公开，0私密',
  `is_admin` int(11) DEFAULT '0' COMMENT '1管理员，0普通用户',
  PRIMARY KEY (`id`),
  UNIQUE KEY `unique_username` (`username`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

LOCK TABLES `user` WRITE;
/*!40000 ALTER TABLE `user` DISABLE KEYS */;

INSERT INTO `user` (`id`, `username`, `password`, `avatar`, `create_time`, `city`, `website`, `company`, `sign`, `github`, `email`, `email_public`, `is_admin`)
VALUES
	(1,'sumory','2d39682dbb53e8b7df86581b0e48a5f8a4f2815617360c4d9607945b5cdde4c5','2.png','2016-01-01 00:08:00','北京','http://sumory.com','here.cn','这就是一条签名','sumory','sumory.wu@gmail.com',1,1),
	(2,'admin','0d74e43cb3e67a56099eb855f0130bf07edf2b7378f4a4fbad69790a5c92ea98','5.png','2016-02-19 19:08:00','北京','http://kefu2.youuue.com/','无','nothing at all.','','poembro@126.com',0,1),
	(6,'jerry','2d39682dbb53e8b7df86581b0e48a5f8a4f2815617360c4d9607945b5cdde4c5','3.png','2016-01-23 00:01:19','','','','','','',0,0),
	(7,'momo','2d39682dbb53e8b7df86581b0e48a5f8a4f2815617360c4d9607945b5cdde4c5','9.png','2016-02-23 00:01:40','','','','','','',0,0),
	(8,'test','2d39682dbb53e8b7df86581b0e48a5f8a4f2815617360c4d9607945b5cdde4c5','1.png','2021-09-20 00:23:56','武汉','','武汉新城','五','','',0,0),
	(9,'ztest','2d39682dbb53e8b7df86581b0e48a5f8a4f2815617360c4d9607945b5cdde4c5','z.png','2022-04-22 19:06:43','','','','','','',0,0),
	(10,'poembro','0d74e43cb3e67a56099eb855f0130bf07edf2b7378f4a4fbad69790a5c92ea98','p.png','2022-04-23 16:21:16','','','','','','',0,0);

/*!40000 ALTER TABLE `user` ENABLE KEYS */;
UNLOCK TABLES;



/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
